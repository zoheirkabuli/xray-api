/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: app/router/command/command.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../common/net/network";
import * as dependency_2 from "./../../../common/serial/typed_message";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace xray.app.router.command {
    export class RoutingContext extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            InboundTag?: string;
            Network?: dependency_1.xray.common.net.Network;
            SourceIPs?: Uint8Array[];
            TargetIPs?: Uint8Array[];
            SourcePort?: number;
            TargetPort?: number;
            TargetDomain?: string;
            Protocol?: string;
            User?: string;
            Attributes?: Map<string, string>;
            OutboundGroupTags?: string[];
            OutboundTag?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4, 11], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("InboundTag" in data && data.InboundTag != undefined) {
                    this.InboundTag = data.InboundTag;
                }
                if ("Network" in data && data.Network != undefined) {
                    this.Network = data.Network;
                }
                if ("SourceIPs" in data && data.SourceIPs != undefined) {
                    this.SourceIPs = data.SourceIPs;
                }
                if ("TargetIPs" in data && data.TargetIPs != undefined) {
                    this.TargetIPs = data.TargetIPs;
                }
                if ("SourcePort" in data && data.SourcePort != undefined) {
                    this.SourcePort = data.SourcePort;
                }
                if ("TargetPort" in data && data.TargetPort != undefined) {
                    this.TargetPort = data.TargetPort;
                }
                if ("TargetDomain" in data && data.TargetDomain != undefined) {
                    this.TargetDomain = data.TargetDomain;
                }
                if ("Protocol" in data && data.Protocol != undefined) {
                    this.Protocol = data.Protocol;
                }
                if ("User" in data && data.User != undefined) {
                    this.User = data.User;
                }
                if ("Attributes" in data && data.Attributes != undefined) {
                    this.Attributes = data.Attributes;
                }
                if ("OutboundGroupTags" in data && data.OutboundGroupTags != undefined) {
                    this.OutboundGroupTags = data.OutboundGroupTags;
                }
                if ("OutboundTag" in data && data.OutboundTag != undefined) {
                    this.OutboundTag = data.OutboundTag;
                }
            }
            if (!this.Attributes)
                this.Attributes = new Map();
        }
        get InboundTag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set InboundTag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Network() {
            return pb_1.Message.getFieldWithDefault(this, 2, dependency_1.xray.common.net.Network.Unknown) as dependency_1.xray.common.net.Network;
        }
        set Network(value: dependency_1.xray.common.net.Network) {
            pb_1.Message.setField(this, 2, value);
        }
        get SourceIPs() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as Uint8Array[];
        }
        set SourceIPs(value: Uint8Array[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get TargetIPs() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as Uint8Array[];
        }
        set TargetIPs(value: Uint8Array[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get SourcePort() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set SourcePort(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get TargetPort() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set TargetPort(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get TargetDomain() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set TargetDomain(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get Protocol() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set Protocol(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get User() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set User(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get Attributes() {
            return pb_1.Message.getField(this, 10) as any as Map<string, string>;
        }
        set Attributes(value: Map<string, string>) {
            pb_1.Message.setField(this, 10, value as any);
        }
        get OutboundGroupTags() {
            return pb_1.Message.getFieldWithDefault(this, 11, []) as string[];
        }
        set OutboundGroupTags(value: string[]) {
            pb_1.Message.setField(this, 11, value);
        }
        get OutboundTag() {
            return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
        }
        set OutboundTag(value: string) {
            pb_1.Message.setField(this, 12, value);
        }
        static fromObject(data: {
            InboundTag?: string;
            Network?: dependency_1.xray.common.net.Network;
            SourceIPs?: Uint8Array[];
            TargetIPs?: Uint8Array[];
            SourcePort?: number;
            TargetPort?: number;
            TargetDomain?: string;
            Protocol?: string;
            User?: string;
            Attributes?: {
                [key: string]: string;
            };
            OutboundGroupTags?: string[];
            OutboundTag?: string;
        }): RoutingContext {
            const message = new RoutingContext({});
            if (data.InboundTag != null) {
                message.InboundTag = data.InboundTag;
            }
            if (data.Network != null) {
                message.Network = data.Network;
            }
            if (data.SourceIPs != null) {
                message.SourceIPs = data.SourceIPs;
            }
            if (data.TargetIPs != null) {
                message.TargetIPs = data.TargetIPs;
            }
            if (data.SourcePort != null) {
                message.SourcePort = data.SourcePort;
            }
            if (data.TargetPort != null) {
                message.TargetPort = data.TargetPort;
            }
            if (data.TargetDomain != null) {
                message.TargetDomain = data.TargetDomain;
            }
            if (data.Protocol != null) {
                message.Protocol = data.Protocol;
            }
            if (data.User != null) {
                message.User = data.User;
            }
            if (typeof data.Attributes == "object") {
                message.Attributes = new Map(Object.entries(data.Attributes));
            }
            if (data.OutboundGroupTags != null) {
                message.OutboundGroupTags = data.OutboundGroupTags;
            }
            if (data.OutboundTag != null) {
                message.OutboundTag = data.OutboundTag;
            }
            return message;
        }
        toObject() {
            const data: {
                InboundTag?: string;
                Network?: dependency_1.xray.common.net.Network;
                SourceIPs?: Uint8Array[];
                TargetIPs?: Uint8Array[];
                SourcePort?: number;
                TargetPort?: number;
                TargetDomain?: string;
                Protocol?: string;
                User?: string;
                Attributes?: {
                    [key: string]: string;
                };
                OutboundGroupTags?: string[];
                OutboundTag?: string;
            } = {};
            if (this.InboundTag != null) {
                data.InboundTag = this.InboundTag;
            }
            if (this.Network != null) {
                data.Network = this.Network;
            }
            if (this.SourceIPs != null) {
                data.SourceIPs = this.SourceIPs;
            }
            if (this.TargetIPs != null) {
                data.TargetIPs = this.TargetIPs;
            }
            if (this.SourcePort != null) {
                data.SourcePort = this.SourcePort;
            }
            if (this.TargetPort != null) {
                data.TargetPort = this.TargetPort;
            }
            if (this.TargetDomain != null) {
                data.TargetDomain = this.TargetDomain;
            }
            if (this.Protocol != null) {
                data.Protocol = this.Protocol;
            }
            if (this.User != null) {
                data.User = this.User;
            }
            if (this.Attributes != null) {
                data.Attributes = (Object.fromEntries)(this.Attributes);
            }
            if (this.OutboundGroupTags != null) {
                data.OutboundGroupTags = this.OutboundGroupTags;
            }
            if (this.OutboundTag != null) {
                data.OutboundTag = this.OutboundTag;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.InboundTag.length)
                writer.writeString(1, this.InboundTag);
            if (this.Network != dependency_1.xray.common.net.Network.Unknown)
                writer.writeEnum(2, this.Network);
            if (this.SourceIPs.length)
                writer.writeRepeatedBytes(3, this.SourceIPs);
            if (this.TargetIPs.length)
                writer.writeRepeatedBytes(4, this.TargetIPs);
            if (this.SourcePort != 0)
                writer.writeUint32(5, this.SourcePort);
            if (this.TargetPort != 0)
                writer.writeUint32(6, this.TargetPort);
            if (this.TargetDomain.length)
                writer.writeString(7, this.TargetDomain);
            if (this.Protocol.length)
                writer.writeString(8, this.Protocol);
            if (this.User.length)
                writer.writeString(9, this.User);
            for (const [key, value] of this.Attributes) {
                writer.writeMessage(10, this.Attributes, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (this.OutboundGroupTags.length)
                writer.writeRepeatedString(11, this.OutboundGroupTags);
            if (this.OutboundTag.length)
                writer.writeString(12, this.OutboundTag);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RoutingContext {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RoutingContext();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.InboundTag = reader.readString();
                        break;
                    case 2:
                        message.Network = reader.readEnum();
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readBytes());
                        break;
                    case 5:
                        message.SourcePort = reader.readUint32();
                        break;
                    case 6:
                        message.TargetPort = reader.readUint32();
                        break;
                    case 7:
                        message.TargetDomain = reader.readString();
                        break;
                    case 8:
                        message.Protocol = reader.readString();
                        break;
                    case 9:
                        message.User = reader.readString();
                        break;
                    case 10:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Attributes as any, reader, reader.readString, reader.readString));
                        break;
                    case 11:
                        pb_1.Message.addToRepeatedField(message, 11, reader.readString());
                        break;
                    case 12:
                        message.OutboundTag = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RoutingContext {
            return RoutingContext.deserialize(bytes);
        }
    }
    export class SubscribeRoutingStatsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            FieldSelectors?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("FieldSelectors" in data && data.FieldSelectors != undefined) {
                    this.FieldSelectors = data.FieldSelectors;
                }
            }
        }
        get FieldSelectors() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set FieldSelectors(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            FieldSelectors?: string[];
        }): SubscribeRoutingStatsRequest {
            const message = new SubscribeRoutingStatsRequest({});
            if (data.FieldSelectors != null) {
                message.FieldSelectors = data.FieldSelectors;
            }
            return message;
        }
        toObject() {
            const data: {
                FieldSelectors?: string[];
            } = {};
            if (this.FieldSelectors != null) {
                data.FieldSelectors = this.FieldSelectors;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.FieldSelectors.length)
                writer.writeRepeatedString(1, this.FieldSelectors);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubscribeRoutingStatsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubscribeRoutingStatsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubscribeRoutingStatsRequest {
            return SubscribeRoutingStatsRequest.deserialize(bytes);
        }
    }
    export class TestRouteRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RoutingContext?: RoutingContext;
            FieldSelectors?: string[];
            PublishResult?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RoutingContext" in data && data.RoutingContext != undefined) {
                    this.RoutingContext = data.RoutingContext;
                }
                if ("FieldSelectors" in data && data.FieldSelectors != undefined) {
                    this.FieldSelectors = data.FieldSelectors;
                }
                if ("PublishResult" in data && data.PublishResult != undefined) {
                    this.PublishResult = data.PublishResult;
                }
            }
        }
        get RoutingContext() {
            return pb_1.Message.getWrapperField(this, RoutingContext, 1) as RoutingContext;
        }
        set RoutingContext(value: RoutingContext) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_RoutingContext() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get FieldSelectors() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set FieldSelectors(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get PublishResult() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set PublishResult(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            RoutingContext?: ReturnType<typeof RoutingContext.prototype.toObject>;
            FieldSelectors?: string[];
            PublishResult?: boolean;
        }): TestRouteRequest {
            const message = new TestRouteRequest({});
            if (data.RoutingContext != null) {
                message.RoutingContext = RoutingContext.fromObject(data.RoutingContext);
            }
            if (data.FieldSelectors != null) {
                message.FieldSelectors = data.FieldSelectors;
            }
            if (data.PublishResult != null) {
                message.PublishResult = data.PublishResult;
            }
            return message;
        }
        toObject() {
            const data: {
                RoutingContext?: ReturnType<typeof RoutingContext.prototype.toObject>;
                FieldSelectors?: string[];
                PublishResult?: boolean;
            } = {};
            if (this.RoutingContext != null) {
                data.RoutingContext = this.RoutingContext.toObject();
            }
            if (this.FieldSelectors != null) {
                data.FieldSelectors = this.FieldSelectors;
            }
            if (this.PublishResult != null) {
                data.PublishResult = this.PublishResult;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_RoutingContext)
                writer.writeMessage(1, this.RoutingContext, () => this.RoutingContext.serialize(writer));
            if (this.FieldSelectors.length)
                writer.writeRepeatedString(2, this.FieldSelectors);
            if (this.PublishResult != false)
                writer.writeBool(3, this.PublishResult);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TestRouteRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TestRouteRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.RoutingContext, () => message.RoutingContext = RoutingContext.deserialize(reader));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.PublishResult = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TestRouteRequest {
            return TestRouteRequest.deserialize(bytes);
        }
    }
    export class PrincipleTargetInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tag?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
            }
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set tag(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            tag?: string[];
        }): PrincipleTargetInfo {
            const message = new PrincipleTargetInfo({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string[];
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tag.length)
                writer.writeRepeatedString(1, this.tag);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PrincipleTargetInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PrincipleTargetInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PrincipleTargetInfo {
            return PrincipleTargetInfo.deserialize(bytes);
        }
    }
    export class OverrideInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            target?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("target" in data && data.target != undefined) {
                    this.target = data.target;
                }
            }
        }
        get target() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set target(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            target?: string;
        }): OverrideInfo {
            const message = new OverrideInfo({});
            if (data.target != null) {
                message.target = data.target;
            }
            return message;
        }
        toObject() {
            const data: {
                target?: string;
            } = {};
            if (this.target != null) {
                data.target = this.target;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.target.length)
                writer.writeString(2, this.target);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OverrideInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OverrideInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.target = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OverrideInfo {
            return OverrideInfo.deserialize(bytes);
        }
    }
    export class BalancerMsg extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            override?: OverrideInfo;
            principle_target?: PrincipleTargetInfo;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("override" in data && data.override != undefined) {
                    this.override = data.override;
                }
                if ("principle_target" in data && data.principle_target != undefined) {
                    this.principle_target = data.principle_target;
                }
            }
        }
        get override() {
            return pb_1.Message.getWrapperField(this, OverrideInfo, 5) as OverrideInfo;
        }
        set override(value: OverrideInfo) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_override() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get principle_target() {
            return pb_1.Message.getWrapperField(this, PrincipleTargetInfo, 6) as PrincipleTargetInfo;
        }
        set principle_target(value: PrincipleTargetInfo) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_principle_target() {
            return pb_1.Message.getField(this, 6) != null;
        }
        static fromObject(data: {
            override?: ReturnType<typeof OverrideInfo.prototype.toObject>;
            principle_target?: ReturnType<typeof PrincipleTargetInfo.prototype.toObject>;
        }): BalancerMsg {
            const message = new BalancerMsg({});
            if (data.override != null) {
                message.override = OverrideInfo.fromObject(data.override);
            }
            if (data.principle_target != null) {
                message.principle_target = PrincipleTargetInfo.fromObject(data.principle_target);
            }
            return message;
        }
        toObject() {
            const data: {
                override?: ReturnType<typeof OverrideInfo.prototype.toObject>;
                principle_target?: ReturnType<typeof PrincipleTargetInfo.prototype.toObject>;
            } = {};
            if (this.override != null) {
                data.override = this.override.toObject();
            }
            if (this.principle_target != null) {
                data.principle_target = this.principle_target.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_override)
                writer.writeMessage(5, this.override, () => this.override.serialize(writer));
            if (this.has_principle_target)
                writer.writeMessage(6, this.principle_target, () => this.principle_target.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BalancerMsg {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BalancerMsg();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 5:
                        reader.readMessage(message.override, () => message.override = OverrideInfo.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.principle_target, () => message.principle_target = PrincipleTargetInfo.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BalancerMsg {
            return BalancerMsg.deserialize(bytes);
        }
    }
    export class GetBalancerInfoRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tag?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
            }
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            tag?: string;
        }): GetBalancerInfoRequest {
            const message = new GetBalancerInfoRequest({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string;
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tag.length)
                writer.writeString(1, this.tag);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetBalancerInfoRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetBalancerInfoRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tag = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetBalancerInfoRequest {
            return GetBalancerInfoRequest.deserialize(bytes);
        }
    }
    export class GetBalancerInfoResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            balancer?: BalancerMsg;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("balancer" in data && data.balancer != undefined) {
                    this.balancer = data.balancer;
                }
            }
        }
        get balancer() {
            return pb_1.Message.getWrapperField(this, BalancerMsg, 1) as BalancerMsg;
        }
        set balancer(value: BalancerMsg) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_balancer() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            balancer?: ReturnType<typeof BalancerMsg.prototype.toObject>;
        }): GetBalancerInfoResponse {
            const message = new GetBalancerInfoResponse({});
            if (data.balancer != null) {
                message.balancer = BalancerMsg.fromObject(data.balancer);
            }
            return message;
        }
        toObject() {
            const data: {
                balancer?: ReturnType<typeof BalancerMsg.prototype.toObject>;
            } = {};
            if (this.balancer != null) {
                data.balancer = this.balancer.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_balancer)
                writer.writeMessage(1, this.balancer, () => this.balancer.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetBalancerInfoResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetBalancerInfoResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.balancer, () => message.balancer = BalancerMsg.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetBalancerInfoResponse {
            return GetBalancerInfoResponse.deserialize(bytes);
        }
    }
    export class OverrideBalancerTargetRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            balancerTag?: string;
            target?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("balancerTag" in data && data.balancerTag != undefined) {
                    this.balancerTag = data.balancerTag;
                }
                if ("target" in data && data.target != undefined) {
                    this.target = data.target;
                }
            }
        }
        get balancerTag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set balancerTag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get target() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set target(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            balancerTag?: string;
            target?: string;
        }): OverrideBalancerTargetRequest {
            const message = new OverrideBalancerTargetRequest({});
            if (data.balancerTag != null) {
                message.balancerTag = data.balancerTag;
            }
            if (data.target != null) {
                message.target = data.target;
            }
            return message;
        }
        toObject() {
            const data: {
                balancerTag?: string;
                target?: string;
            } = {};
            if (this.balancerTag != null) {
                data.balancerTag = this.balancerTag;
            }
            if (this.target != null) {
                data.target = this.target;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.balancerTag.length)
                writer.writeString(1, this.balancerTag);
            if (this.target.length)
                writer.writeString(2, this.target);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OverrideBalancerTargetRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OverrideBalancerTargetRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.balancerTag = reader.readString();
                        break;
                    case 2:
                        message.target = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OverrideBalancerTargetRequest {
            return OverrideBalancerTargetRequest.deserialize(bytes);
        }
    }
    export class OverrideBalancerTargetResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): OverrideBalancerTargetResponse {
            const message = new OverrideBalancerTargetResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OverrideBalancerTargetResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OverrideBalancerTargetResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OverrideBalancerTargetResponse {
            return OverrideBalancerTargetResponse.deserialize(bytes);
        }
    }
    export class AddRuleRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            config?: dependency_2.xray.common.serial.TypedMessage;
            shouldAppend?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("config" in data && data.config != undefined) {
                    this.config = data.config;
                }
                if ("shouldAppend" in data && data.shouldAppend != undefined) {
                    this.shouldAppend = data.shouldAppend;
                }
            }
        }
        get config() {
            return pb_1.Message.getWrapperField(this, dependency_2.xray.common.serial.TypedMessage, 1) as dependency_2.xray.common.serial.TypedMessage;
        }
        set config(value: dependency_2.xray.common.serial.TypedMessage) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_config() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get shouldAppend() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set shouldAppend(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            config?: ReturnType<typeof dependency_2.xray.common.serial.TypedMessage.prototype.toObject>;
            shouldAppend?: boolean;
        }): AddRuleRequest {
            const message = new AddRuleRequest({});
            if (data.config != null) {
                message.config = dependency_2.xray.common.serial.TypedMessage.fromObject(data.config);
            }
            if (data.shouldAppend != null) {
                message.shouldAppend = data.shouldAppend;
            }
            return message;
        }
        toObject() {
            const data: {
                config?: ReturnType<typeof dependency_2.xray.common.serial.TypedMessage.prototype.toObject>;
                shouldAppend?: boolean;
            } = {};
            if (this.config != null) {
                data.config = this.config.toObject();
            }
            if (this.shouldAppend != null) {
                data.shouldAppend = this.shouldAppend;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_config)
                writer.writeMessage(1, this.config, () => this.config.serialize(writer));
            if (this.shouldAppend != false)
                writer.writeBool(2, this.shouldAppend);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddRuleRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddRuleRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.config, () => message.config = dependency_2.xray.common.serial.TypedMessage.deserialize(reader));
                        break;
                    case 2:
                        message.shouldAppend = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddRuleRequest {
            return AddRuleRequest.deserialize(bytes);
        }
    }
    export class AddRuleResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): AddRuleResponse {
            const message = new AddRuleResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddRuleResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AddRuleResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AddRuleResponse {
            return AddRuleResponse.deserialize(bytes);
        }
    }
    export class RemoveRuleRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ruleTag?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ruleTag" in data && data.ruleTag != undefined) {
                    this.ruleTag = data.ruleTag;
                }
            }
        }
        get ruleTag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set ruleTag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            ruleTag?: string;
        }): RemoveRuleRequest {
            const message = new RemoveRuleRequest({});
            if (data.ruleTag != null) {
                message.ruleTag = data.ruleTag;
            }
            return message;
        }
        toObject() {
            const data: {
                ruleTag?: string;
            } = {};
            if (this.ruleTag != null) {
                data.ruleTag = this.ruleTag;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ruleTag.length)
                writer.writeString(1, this.ruleTag);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RemoveRuleRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RemoveRuleRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ruleTag = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RemoveRuleRequest {
            return RemoveRuleRequest.deserialize(bytes);
        }
    }
    export class RemoveRuleResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): RemoveRuleResponse {
            const message = new RemoveRuleResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RemoveRuleResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RemoveRuleResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RemoveRuleResponse {
            return RemoveRuleResponse.deserialize(bytes);
        }
    }
    export class Config extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): Config {
            const message = new Config({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Config {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Config();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Config {
            return Config.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedRoutingServiceService {
        static definition = {
            SubscribeRoutingStats: {
                path: "/xray.app.router.command.RoutingService/SubscribeRoutingStats",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: SubscribeRoutingStatsRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SubscribeRoutingStatsRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: RoutingContext) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => RoutingContext.deserialize(new Uint8Array(bytes))
            },
            TestRoute: {
                path: "/xray.app.router.command.RoutingService/TestRoute",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: TestRouteRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => TestRouteRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: RoutingContext) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => RoutingContext.deserialize(new Uint8Array(bytes))
            },
            GetBalancerInfo: {
                path: "/xray.app.router.command.RoutingService/GetBalancerInfo",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetBalancerInfoRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetBalancerInfoRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetBalancerInfoResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetBalancerInfoResponse.deserialize(new Uint8Array(bytes))
            },
            OverrideBalancerTarget: {
                path: "/xray.app.router.command.RoutingService/OverrideBalancerTarget",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: OverrideBalancerTargetRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => OverrideBalancerTargetRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: OverrideBalancerTargetResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => OverrideBalancerTargetResponse.deserialize(new Uint8Array(bytes))
            },
            AddRule: {
                path: "/xray.app.router.command.RoutingService/AddRule",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: AddRuleRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => AddRuleRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: AddRuleResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => AddRuleResponse.deserialize(new Uint8Array(bytes))
            },
            RemoveRule: {
                path: "/xray.app.router.command.RoutingService/RemoveRule",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: RemoveRuleRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => RemoveRuleRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: RemoveRuleResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => RemoveRuleResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract SubscribeRoutingStats(call: grpc_1.ServerWritableStream<SubscribeRoutingStatsRequest, RoutingContext>): void;
        abstract TestRoute(call: grpc_1.ServerUnaryCall<TestRouteRequest, RoutingContext>, callback: grpc_1.sendUnaryData<RoutingContext>): void;
        abstract GetBalancerInfo(call: grpc_1.ServerUnaryCall<GetBalancerInfoRequest, GetBalancerInfoResponse>, callback: grpc_1.sendUnaryData<GetBalancerInfoResponse>): void;
        abstract OverrideBalancerTarget(call: grpc_1.ServerUnaryCall<OverrideBalancerTargetRequest, OverrideBalancerTargetResponse>, callback: grpc_1.sendUnaryData<OverrideBalancerTargetResponse>): void;
        abstract AddRule(call: grpc_1.ServerUnaryCall<AddRuleRequest, AddRuleResponse>, callback: grpc_1.sendUnaryData<AddRuleResponse>): void;
        abstract RemoveRule(call: grpc_1.ServerUnaryCall<RemoveRuleRequest, RemoveRuleResponse>, callback: grpc_1.sendUnaryData<RemoveRuleResponse>): void;
    }
    export class RoutingServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedRoutingServiceService.definition, "RoutingService", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        SubscribeRoutingStats: GrpcStreamServiceInterface<SubscribeRoutingStatsRequest, RoutingContext> = (message: SubscribeRoutingStatsRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<RoutingContext> => {
            return super.SubscribeRoutingStats(message, metadata, options);
        };
        TestRoute: GrpcUnaryServiceInterface<TestRouteRequest, RoutingContext> = (message: TestRouteRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<RoutingContext>, options?: grpc_1.CallOptions | grpc_1.requestCallback<RoutingContext>, callback?: grpc_1.requestCallback<RoutingContext>): grpc_1.ClientUnaryCall => {
            return super.TestRoute(message, metadata, options, callback);
        };
        GetBalancerInfo: GrpcUnaryServiceInterface<GetBalancerInfoRequest, GetBalancerInfoResponse> = (message: GetBalancerInfoRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetBalancerInfoResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetBalancerInfoResponse>, callback?: grpc_1.requestCallback<GetBalancerInfoResponse>): grpc_1.ClientUnaryCall => {
            return super.GetBalancerInfo(message, metadata, options, callback);
        };
        OverrideBalancerTarget: GrpcUnaryServiceInterface<OverrideBalancerTargetRequest, OverrideBalancerTargetResponse> = (message: OverrideBalancerTargetRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<OverrideBalancerTargetResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<OverrideBalancerTargetResponse>, callback?: grpc_1.requestCallback<OverrideBalancerTargetResponse>): grpc_1.ClientUnaryCall => {
            return super.OverrideBalancerTarget(message, metadata, options, callback);
        };
        AddRule: GrpcUnaryServiceInterface<AddRuleRequest, AddRuleResponse> = (message: AddRuleRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<AddRuleResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<AddRuleResponse>, callback?: grpc_1.requestCallback<AddRuleResponse>): grpc_1.ClientUnaryCall => {
            return super.AddRule(message, metadata, options, callback);
        };
        RemoveRule: GrpcUnaryServiceInterface<RemoveRuleRequest, RemoveRuleResponse> = (message: RemoveRuleRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<RemoveRuleResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<RemoveRuleResponse>, callback?: grpc_1.requestCallback<RemoveRuleResponse>): grpc_1.ClientUnaryCall => {
            return super.RemoveRule(message, metadata, options, callback);
        };
    }
}
