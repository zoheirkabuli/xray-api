// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.3
//   protoc               v6.31.1
// source: app/router/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Network, networkFromJSON, networkToJSON } from "../../common/net/network";
import { PortList } from "../../common/net/port";
import { TypedMessage } from "../../common/serial/typed_message";

export const protobufPackage = "xray.app.router";

/** Domain for routing decision. */
export interface Domain {
  /** Domain matching type. */
  type: Domain_Type;
  /** Domain value. */
  value: string;
  /** Attributes of this domain. May be used for filtering. */
  attribute: Domain_Attribute[];
}

/** Type of domain value. */
export enum Domain_Type {
  /** Plain - The value is used as is. */
  Plain = 0,
  /** Regex - The value is used as a regular expression. */
  Regex = 1,
  /** Domain - The value is a root domain. */
  Domain = 2,
  /** Full - The value is a domain. */
  Full = 3,
  UNRECOGNIZED = -1,
}

export function domain_TypeFromJSON(object: any): Domain_Type {
  switch (object) {
    case 0:
    case "Plain":
      return Domain_Type.Plain;
    case 1:
    case "Regex":
      return Domain_Type.Regex;
    case 2:
    case "Domain":
      return Domain_Type.Domain;
    case 3:
    case "Full":
      return Domain_Type.Full;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Domain_Type.UNRECOGNIZED;
  }
}

export function domain_TypeToJSON(object: Domain_Type): string {
  switch (object) {
    case Domain_Type.Plain:
      return "Plain";
    case Domain_Type.Regex:
      return "Regex";
    case Domain_Type.Domain:
      return "Domain";
    case Domain_Type.Full:
      return "Full";
    case Domain_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Domain_Attribute {
  key: string;
  boolValue?: boolean | undefined;
  intValue?: number | undefined;
}

/** IP for routing decision, in CIDR form. */
export interface CIDR {
  /** IP address, should be either 4 or 16 bytes. */
  ip: Uint8Array;
  /** Number of leading ones in the network mask. */
  prefix: number;
}

export interface GeoIP {
  countryCode: string;
  cidr: CIDR[];
  reverseMatch: boolean;
}

export interface GeoIPList {
  entry: GeoIP[];
}

export interface GeoSite {
  countryCode: string;
  domain: Domain[];
}

export interface GeoSiteList {
  entry: GeoSite[];
}

export interface RoutingRule {
  /** Tag of outbound that this rule is pointing to. */
  tag?:
    | string
    | undefined;
  /** Tag of routing balancer. */
  balancingTag?: string | undefined;
  ruleTag: string;
  /** List of domains for target domain matching. */
  domain: Domain[];
  /**
   * List of GeoIPs for target IP address matching. If this entry exists, the
   * cidr above will have no effect. GeoIP fields with the same country code are
   * supposed to contain exactly same content. They will be merged during
   * runtime. For customized GeoIPs, please leave country code empty.
   */
  geoip: GeoIP[];
  /** List of ports. */
  portList:
    | PortList
    | undefined;
  /** List of networks for matching. */
  networks: Network[];
  /**
   * List of GeoIPs for source IP address matching. If this entry exists, the
   * source_cidr above will have no effect.
   */
  sourceGeoip: GeoIP[];
  /** List of ports for source port matching. */
  sourcePortList: PortList | undefined;
  userEmail: string[];
  inboundTag: string[];
  protocol: string[];
  attributes: { [key: string]: string };
  domainMatcher: string;
}

export interface RoutingRule_AttributesEntry {
  key: string;
  value: string;
}

export interface BalancingRule {
  tag: string;
  outboundSelector: string[];
  strategy: string;
  strategySettings: TypedMessage | undefined;
  fallbackTag: string;
}

export interface StrategyWeight {
  regexp: boolean;
  match: string;
  value: number;
}

export interface StrategyLeastLoadConfig {
  /** weight settings */
  costs: StrategyWeight[];
  /** RTT baselines for selecting, int64 values of time.Duration */
  baselines: number[];
  /** expected nodes count to select */
  expected: number;
  /** max acceptable rtt, filter away high delay nodes. default 0 */
  maxRTT: number;
  /** acceptable failure rate */
  tolerance: number;
}

export interface Config {
  domainStrategy: Config_DomainStrategy;
  rule: RoutingRule[];
  balancingRule: BalancingRule[];
}

export enum Config_DomainStrategy {
  /** AsIs - Use domain as is. */
  AsIs = 0,
  /** UseIp - Always resolve IP for domains. */
  UseIp = 1,
  /** IpIfNonMatch - Resolve to IP if the domain doesn't match any rules. */
  IpIfNonMatch = 2,
  /** IpOnDemand - Resolve to IP if any rule requires IP matching. */
  IpOnDemand = 3,
  UNRECOGNIZED = -1,
}

export function config_DomainStrategyFromJSON(object: any): Config_DomainStrategy {
  switch (object) {
    case 0:
    case "AsIs":
      return Config_DomainStrategy.AsIs;
    case 1:
    case "UseIp":
      return Config_DomainStrategy.UseIp;
    case 2:
    case "IpIfNonMatch":
      return Config_DomainStrategy.IpIfNonMatch;
    case 3:
    case "IpOnDemand":
      return Config_DomainStrategy.IpOnDemand;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Config_DomainStrategy.UNRECOGNIZED;
  }
}

export function config_DomainStrategyToJSON(object: Config_DomainStrategy): string {
  switch (object) {
    case Config_DomainStrategy.AsIs:
      return "AsIs";
    case Config_DomainStrategy.UseIp:
      return "UseIp";
    case Config_DomainStrategy.IpIfNonMatch:
      return "IpIfNonMatch";
    case Config_DomainStrategy.IpOnDemand:
      return "IpOnDemand";
    case Config_DomainStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDomain(): Domain {
  return { type: 0, value: "", attribute: [] };
}

export const Domain: MessageFns<Domain> = {
  encode(message: Domain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    for (const v of message.attribute) {
      Domain_Attribute.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Domain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attribute.push(Domain_Attribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Domain {
    return {
      type: isSet(object.type) ? domain_TypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      attribute: globalThis.Array.isArray(object?.attribute)
        ? object.attribute.map((e: any) => Domain_Attribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Domain): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = domain_TypeToJSON(message.type);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.attribute?.length) {
      obj.attribute = message.attribute.map((e) => Domain_Attribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Domain>, I>>(base?: I): Domain {
    return Domain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Domain>, I>>(object: I): Domain {
    const message = createBaseDomain();
    message.type = object.type ?? 0;
    message.value = object.value ?? "";
    message.attribute = object.attribute?.map((e) => Domain_Attribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDomain_Attribute(): Domain_Attribute {
  return { key: "", boolValue: undefined, intValue: undefined };
}

export const Domain_Attribute: MessageFns<Domain_Attribute> = {
  encode(message: Domain_Attribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(24).int64(message.intValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Domain_Attribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomain_Attribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.intValue = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Domain_Attribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
    };
  },

  toJSON(message: Domain_Attribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Domain_Attribute>, I>>(base?: I): Domain_Attribute {
    return Domain_Attribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Domain_Attribute>, I>>(object: I): Domain_Attribute {
    const message = createBaseDomain_Attribute();
    message.key = object.key ?? "";
    message.boolValue = object.boolValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    return message;
  },
};

function createBaseCIDR(): CIDR {
  return { ip: new Uint8Array(0), prefix: 0 };
}

export const CIDR: MessageFns<CIDR> = {
  encode(message: CIDR, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip.length !== 0) {
      writer.uint32(10).bytes(message.ip);
    }
    if (message.prefix !== 0) {
      writer.uint32(16).uint32(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CIDR {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCIDR();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.prefix = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CIDR {
    return {
      ip: isSet(object.ip) ? bytesFromBase64(object.ip) : new Uint8Array(0),
      prefix: isSet(object.prefix) ? globalThis.Number(object.prefix) : 0,
    };
  },

  toJSON(message: CIDR): unknown {
    const obj: any = {};
    if (message.ip.length !== 0) {
      obj.ip = base64FromBytes(message.ip);
    }
    if (message.prefix !== 0) {
      obj.prefix = Math.round(message.prefix);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CIDR>, I>>(base?: I): CIDR {
    return CIDR.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CIDR>, I>>(object: I): CIDR {
    const message = createBaseCIDR();
    message.ip = object.ip ?? new Uint8Array(0);
    message.prefix = object.prefix ?? 0;
    return message;
  },
};

function createBaseGeoIP(): GeoIP {
  return { countryCode: "", cidr: [], reverseMatch: false };
}

export const GeoIP: MessageFns<GeoIP> = {
  encode(message: GeoIP, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    for (const v of message.cidr) {
      CIDR.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.reverseMatch !== false) {
      writer.uint32(24).bool(message.reverseMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoIP {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoIP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cidr.push(CIDR.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reverseMatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoIP {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      cidr: globalThis.Array.isArray(object?.cidr) ? object.cidr.map((e: any) => CIDR.fromJSON(e)) : [],
      reverseMatch: isSet(object.reverseMatch) ? globalThis.Boolean(object.reverseMatch) : false,
    };
  },

  toJSON(message: GeoIP): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.cidr?.length) {
      obj.cidr = message.cidr.map((e) => CIDR.toJSON(e));
    }
    if (message.reverseMatch !== false) {
      obj.reverseMatch = message.reverseMatch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoIP>, I>>(base?: I): GeoIP {
    return GeoIP.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoIP>, I>>(object: I): GeoIP {
    const message = createBaseGeoIP();
    message.countryCode = object.countryCode ?? "";
    message.cidr = object.cidr?.map((e) => CIDR.fromPartial(e)) || [];
    message.reverseMatch = object.reverseMatch ?? false;
    return message;
  },
};

function createBaseGeoIPList(): GeoIPList {
  return { entry: [] };
}

export const GeoIPList: MessageFns<GeoIPList> = {
  encode(message: GeoIPList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entry) {
      GeoIP.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoIPList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoIPList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry.push(GeoIP.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoIPList {
    return { entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e: any) => GeoIP.fromJSON(e)) : [] };
  },

  toJSON(message: GeoIPList): unknown {
    const obj: any = {};
    if (message.entry?.length) {
      obj.entry = message.entry.map((e) => GeoIP.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoIPList>, I>>(base?: I): GeoIPList {
    return GeoIPList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoIPList>, I>>(object: I): GeoIPList {
    const message = createBaseGeoIPList();
    message.entry = object.entry?.map((e) => GeoIP.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeoSite(): GeoSite {
  return { countryCode: "", domain: [] };
}

export const GeoSite: MessageFns<GeoSite> = {
  encode(message: GeoSite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    for (const v of message.domain) {
      Domain.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoSite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoSite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain.push(Domain.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoSite {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      domain: globalThis.Array.isArray(object?.domain) ? object.domain.map((e: any) => Domain.fromJSON(e)) : [],
    };
  },

  toJSON(message: GeoSite): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.domain?.length) {
      obj.domain = message.domain.map((e) => Domain.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoSite>, I>>(base?: I): GeoSite {
    return GeoSite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoSite>, I>>(object: I): GeoSite {
    const message = createBaseGeoSite();
    message.countryCode = object.countryCode ?? "";
    message.domain = object.domain?.map((e) => Domain.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeoSiteList(): GeoSiteList {
  return { entry: [] };
}

export const GeoSiteList: MessageFns<GeoSiteList> = {
  encode(message: GeoSiteList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entry) {
      GeoSite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoSiteList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoSiteList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry.push(GeoSite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoSiteList {
    return { entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e: any) => GeoSite.fromJSON(e)) : [] };
  },

  toJSON(message: GeoSiteList): unknown {
    const obj: any = {};
    if (message.entry?.length) {
      obj.entry = message.entry.map((e) => GeoSite.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoSiteList>, I>>(base?: I): GeoSiteList {
    return GeoSiteList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoSiteList>, I>>(object: I): GeoSiteList {
    const message = createBaseGeoSiteList();
    message.entry = object.entry?.map((e) => GeoSite.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoutingRule(): RoutingRule {
  return {
    tag: undefined,
    balancingTag: undefined,
    ruleTag: "",
    domain: [],
    geoip: [],
    portList: undefined,
    networks: [],
    sourceGeoip: [],
    sourcePortList: undefined,
    userEmail: [],
    inboundTag: [],
    protocol: [],
    attributes: {},
    domainMatcher: "",
  };
}

export const RoutingRule: MessageFns<RoutingRule> = {
  encode(message: RoutingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== undefined) {
      writer.uint32(10).string(message.tag);
    }
    if (message.balancingTag !== undefined) {
      writer.uint32(98).string(message.balancingTag);
    }
    if (message.ruleTag !== "") {
      writer.uint32(146).string(message.ruleTag);
    }
    for (const v of message.domain) {
      Domain.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.geoip) {
      GeoIP.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.portList !== undefined) {
      PortList.encode(message.portList, writer.uint32(114).fork()).join();
    }
    writer.uint32(106).fork();
    for (const v of message.networks) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.sourceGeoip) {
      GeoIP.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.sourcePortList !== undefined) {
      PortList.encode(message.sourcePortList, writer.uint32(130).fork()).join();
    }
    for (const v of message.userEmail) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.inboundTag) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.protocol) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      RoutingRule_AttributesEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.domainMatcher !== "") {
      writer.uint32(138).string(message.domainMatcher);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.balancingTag = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.ruleTag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain.push(Domain.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.geoip.push(GeoIP.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.portList = PortList.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.networks.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.networks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sourceGeoip.push(GeoIP.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sourcePortList = PortList.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userEmail.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inboundTag.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.protocol.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = RoutingRule_AttributesEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.attributes[entry15.key] = entry15.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.domainMatcher = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingRule {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      balancingTag: isSet(object.balancingTag) ? globalThis.String(object.balancingTag) : undefined,
      ruleTag: isSet(object.ruleTag) ? globalThis.String(object.ruleTag) : "",
      domain: globalThis.Array.isArray(object?.domain) ? object.domain.map((e: any) => Domain.fromJSON(e)) : [],
      geoip: globalThis.Array.isArray(object?.geoip) ? object.geoip.map((e: any) => GeoIP.fromJSON(e)) : [],
      portList: isSet(object.portList) ? PortList.fromJSON(object.portList) : undefined,
      networks: globalThis.Array.isArray(object?.networks) ? object.networks.map((e: any) => networkFromJSON(e)) : [],
      sourceGeoip: globalThis.Array.isArray(object?.sourceGeoip)
        ? object.sourceGeoip.map((e: any) => GeoIP.fromJSON(e))
        : [],
      sourcePortList: isSet(object.sourcePortList) ? PortList.fromJSON(object.sourcePortList) : undefined,
      userEmail: globalThis.Array.isArray(object?.userEmail)
        ? object.userEmail.map((e: any) => globalThis.String(e))
        : [],
      inboundTag: globalThis.Array.isArray(object?.inboundTag)
        ? object.inboundTag.map((e: any) => globalThis.String(e))
        : [],
      protocol: globalThis.Array.isArray(object?.protocol) ? object.protocol.map((e: any) => globalThis.String(e)) : [],
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      domainMatcher: isSet(object.domainMatcher) ? globalThis.String(object.domainMatcher) : "",
    };
  },

  toJSON(message: RoutingRule): unknown {
    const obj: any = {};
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.balancingTag !== undefined) {
      obj.balancingTag = message.balancingTag;
    }
    if (message.ruleTag !== "") {
      obj.ruleTag = message.ruleTag;
    }
    if (message.domain?.length) {
      obj.domain = message.domain.map((e) => Domain.toJSON(e));
    }
    if (message.geoip?.length) {
      obj.geoip = message.geoip.map((e) => GeoIP.toJSON(e));
    }
    if (message.portList !== undefined) {
      obj.portList = PortList.toJSON(message.portList);
    }
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => networkToJSON(e));
    }
    if (message.sourceGeoip?.length) {
      obj.sourceGeoip = message.sourceGeoip.map((e) => GeoIP.toJSON(e));
    }
    if (message.sourcePortList !== undefined) {
      obj.sourcePortList = PortList.toJSON(message.sourcePortList);
    }
    if (message.userEmail?.length) {
      obj.userEmail = message.userEmail;
    }
    if (message.inboundTag?.length) {
      obj.inboundTag = message.inboundTag;
    }
    if (message.protocol?.length) {
      obj.protocol = message.protocol;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.domainMatcher !== "") {
      obj.domainMatcher = message.domainMatcher;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingRule>, I>>(base?: I): RoutingRule {
    return RoutingRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingRule>, I>>(object: I): RoutingRule {
    const message = createBaseRoutingRule();
    message.tag = object.tag ?? undefined;
    message.balancingTag = object.balancingTag ?? undefined;
    message.ruleTag = object.ruleTag ?? "";
    message.domain = object.domain?.map((e) => Domain.fromPartial(e)) || [];
    message.geoip = object.geoip?.map((e) => GeoIP.fromPartial(e)) || [];
    message.portList = (object.portList !== undefined && object.portList !== null)
      ? PortList.fromPartial(object.portList)
      : undefined;
    message.networks = object.networks?.map((e) => e) || [];
    message.sourceGeoip = object.sourceGeoip?.map((e) => GeoIP.fromPartial(e)) || [];
    message.sourcePortList = (object.sourcePortList !== undefined && object.sourcePortList !== null)
      ? PortList.fromPartial(object.sourcePortList)
      : undefined;
    message.userEmail = object.userEmail?.map((e) => e) || [];
    message.inboundTag = object.inboundTag?.map((e) => e) || [];
    message.protocol = object.protocol?.map((e) => e) || [];
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.domainMatcher = object.domainMatcher ?? "";
    return message;
  },
};

function createBaseRoutingRule_AttributesEntry(): RoutingRule_AttributesEntry {
  return { key: "", value: "" };
}

export const RoutingRule_AttributesEntry: MessageFns<RoutingRule_AttributesEntry> = {
  encode(message: RoutingRule_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingRule_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingRule_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingRule_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RoutingRule_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingRule_AttributesEntry>, I>>(base?: I): RoutingRule_AttributesEntry {
    return RoutingRule_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingRule_AttributesEntry>, I>>(object: I): RoutingRule_AttributesEntry {
    const message = createBaseRoutingRule_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBalancingRule(): BalancingRule {
  return { tag: "", outboundSelector: [], strategy: "", strategySettings: undefined, fallbackTag: "" };
}

export const BalancingRule: MessageFns<BalancingRule> = {
  encode(message: BalancingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    for (const v of message.outboundSelector) {
      writer.uint32(18).string(v!);
    }
    if (message.strategy !== "") {
      writer.uint32(26).string(message.strategy);
    }
    if (message.strategySettings !== undefined) {
      TypedMessage.encode(message.strategySettings, writer.uint32(34).fork()).join();
    }
    if (message.fallbackTag !== "") {
      writer.uint32(42).string(message.fallbackTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalancingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalancingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outboundSelector.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.strategySettings = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fallbackTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalancingRule {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      outboundSelector: globalThis.Array.isArray(object?.outboundSelector)
        ? object.outboundSelector.map((e: any) => globalThis.String(e))
        : [],
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
      strategySettings: isSet(object.strategySettings) ? TypedMessage.fromJSON(object.strategySettings) : undefined,
      fallbackTag: isSet(object.fallbackTag) ? globalThis.String(object.fallbackTag) : "",
    };
  },

  toJSON(message: BalancingRule): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.outboundSelector?.length) {
      obj.outboundSelector = message.outboundSelector;
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    if (message.strategySettings !== undefined) {
      obj.strategySettings = TypedMessage.toJSON(message.strategySettings);
    }
    if (message.fallbackTag !== "") {
      obj.fallbackTag = message.fallbackTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalancingRule>, I>>(base?: I): BalancingRule {
    return BalancingRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalancingRule>, I>>(object: I): BalancingRule {
    const message = createBaseBalancingRule();
    message.tag = object.tag ?? "";
    message.outboundSelector = object.outboundSelector?.map((e) => e) || [];
    message.strategy = object.strategy ?? "";
    message.strategySettings = (object.strategySettings !== undefined && object.strategySettings !== null)
      ? TypedMessage.fromPartial(object.strategySettings)
      : undefined;
    message.fallbackTag = object.fallbackTag ?? "";
    return message;
  },
};

function createBaseStrategyWeight(): StrategyWeight {
  return { regexp: false, match: "", value: 0 };
}

export const StrategyWeight: MessageFns<StrategyWeight> = {
  encode(message: StrategyWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regexp !== false) {
      writer.uint32(8).bool(message.regexp);
    }
    if (message.match !== "") {
      writer.uint32(18).string(message.match);
    }
    if (message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrategyWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.regexp = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.match = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyWeight {
    return {
      regexp: isSet(object.regexp) ? globalThis.Boolean(object.regexp) : false,
      match: isSet(object.match) ? globalThis.String(object.match) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: StrategyWeight): unknown {
    const obj: any = {};
    if (message.regexp !== false) {
      obj.regexp = message.regexp;
    }
    if (message.match !== "") {
      obj.match = message.match;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StrategyWeight>, I>>(base?: I): StrategyWeight {
    return StrategyWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StrategyWeight>, I>>(object: I): StrategyWeight {
    const message = createBaseStrategyWeight();
    message.regexp = object.regexp ?? false;
    message.match = object.match ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseStrategyLeastLoadConfig(): StrategyLeastLoadConfig {
  return { costs: [], baselines: [], expected: 0, maxRTT: 0, tolerance: 0 };
}

export const StrategyLeastLoadConfig: MessageFns<StrategyLeastLoadConfig> = {
  encode(message: StrategyLeastLoadConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.costs) {
      StrategyWeight.encode(v!, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.baselines) {
      writer.int64(v);
    }
    writer.join();
    if (message.expected !== 0) {
      writer.uint32(32).int32(message.expected);
    }
    if (message.maxRTT !== 0) {
      writer.uint32(40).int64(message.maxRTT);
    }
    if (message.tolerance !== 0) {
      writer.uint32(53).float(message.tolerance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrategyLeastLoadConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategyLeastLoadConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.costs.push(StrategyWeight.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.baselines.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.baselines.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expected = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxRTT = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.tolerance = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrategyLeastLoadConfig {
    return {
      costs: globalThis.Array.isArray(object?.costs) ? object.costs.map((e: any) => StrategyWeight.fromJSON(e)) : [],
      baselines: globalThis.Array.isArray(object?.baselines)
        ? object.baselines.map((e: any) => globalThis.Number(e))
        : [],
      expected: isSet(object.expected) ? globalThis.Number(object.expected) : 0,
      maxRTT: isSet(object.maxRTT) ? globalThis.Number(object.maxRTT) : 0,
      tolerance: isSet(object.tolerance) ? globalThis.Number(object.tolerance) : 0,
    };
  },

  toJSON(message: StrategyLeastLoadConfig): unknown {
    const obj: any = {};
    if (message.costs?.length) {
      obj.costs = message.costs.map((e) => StrategyWeight.toJSON(e));
    }
    if (message.baselines?.length) {
      obj.baselines = message.baselines.map((e) => Math.round(e));
    }
    if (message.expected !== 0) {
      obj.expected = Math.round(message.expected);
    }
    if (message.maxRTT !== 0) {
      obj.maxRTT = Math.round(message.maxRTT);
    }
    if (message.tolerance !== 0) {
      obj.tolerance = message.tolerance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StrategyLeastLoadConfig>, I>>(base?: I): StrategyLeastLoadConfig {
    return StrategyLeastLoadConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StrategyLeastLoadConfig>, I>>(object: I): StrategyLeastLoadConfig {
    const message = createBaseStrategyLeastLoadConfig();
    message.costs = object.costs?.map((e) => StrategyWeight.fromPartial(e)) || [];
    message.baselines = object.baselines?.map((e) => e) || [];
    message.expected = object.expected ?? 0;
    message.maxRTT = object.maxRTT ?? 0;
    message.tolerance = object.tolerance ?? 0;
    return message;
  },
};

function createBaseConfig(): Config {
  return { domainStrategy: 0, rule: [], balancingRule: [] };
}

export const Config: MessageFns<Config> = {
  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domainStrategy !== 0) {
      writer.uint32(8).int32(message.domainStrategy);
    }
    for (const v of message.rule) {
      RoutingRule.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.balancingRule) {
      BalancingRule.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domainStrategy = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule.push(RoutingRule.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.balancingRule.push(BalancingRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      domainStrategy: isSet(object.domainStrategy) ? config_DomainStrategyFromJSON(object.domainStrategy) : 0,
      rule: globalThis.Array.isArray(object?.rule) ? object.rule.map((e: any) => RoutingRule.fromJSON(e)) : [],
      balancingRule: globalThis.Array.isArray(object?.balancingRule)
        ? object.balancingRule.map((e: any) => BalancingRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.domainStrategy !== 0) {
      obj.domainStrategy = config_DomainStrategyToJSON(message.domainStrategy);
    }
    if (message.rule?.length) {
      obj.rule = message.rule.map((e) => RoutingRule.toJSON(e));
    }
    if (message.balancingRule?.length) {
      obj.balancingRule = message.balancingRule.map((e) => BalancingRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.domainStrategy = object.domainStrategy ?? 0;
    message.rule = object.rule?.map((e) => RoutingRule.fromPartial(e)) || [];
    message.balancingRule = object.balancingRule?.map((e) => BalancingRule.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
