/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: app/router/config.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../common/serial/typed_message";
import * as dependency_2 from "./../../common/net/port";
import * as dependency_3 from "./../../common/net/network";
import * as pb_1 from "google-protobuf";
export namespace xray.app.router {
    export class Domain extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: Domain.Type;
            value?: string;
            attribute?: Domain.Attribute[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("attribute" in data && data.attribute != undefined) {
                    this.attribute = data.attribute;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, Domain.Type.Plain) as Domain.Type;
        }
        set type(value: Domain.Type) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get attribute() {
            return pb_1.Message.getRepeatedWrapperField(this, Domain.Attribute, 3) as Domain.Attribute[];
        }
        set attribute(value: Domain.Attribute[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            type?: Domain.Type;
            value?: string;
            attribute?: ReturnType<typeof Domain.Attribute.prototype.toObject>[];
        }): Domain {
            const message = new Domain({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.attribute != null) {
                message.attribute = data.attribute.map(item => Domain.Attribute.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                type?: Domain.Type;
                value?: string;
                attribute?: ReturnType<typeof Domain.Attribute.prototype.toObject>[];
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.attribute != null) {
                data.attribute = this.attribute.map((item: Domain.Attribute) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != Domain.Type.Plain)
                writer.writeEnum(1, this.type);
            if (this.value.length)
                writer.writeString(2, this.value);
            if (this.attribute.length)
                writer.writeRepeatedMessage(3, this.attribute, (item: Domain.Attribute) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Domain {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Domain();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.value = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.attribute, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Domain.Attribute.deserialize(reader), Domain.Attribute));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Domain {
            return Domain.deserialize(bytes);
        }
    }
    export namespace Domain {
        export enum Type {
            Plain = 0,
            Regex = 1,
            Domain = 2,
            Full = 3
        }
        export class Attribute extends pb_1.Message {
            #one_of_decls: number[][] = [[2, 3]];
            constructor(data?: any[] | ({
                key?: string;
            } & (({
                bool_value?: boolean;
                int_value?: never;
            } | {
                bool_value?: never;
                int_value?: number;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                    if ("bool_value" in data && data.bool_value != undefined) {
                        this.bool_value = data.bool_value;
                    }
                    if ("int_value" in data && data.int_value != undefined) {
                        this.int_value = data.int_value;
                    }
                }
            }
            get key() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set key(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get bool_value() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set bool_value(value: boolean) {
                pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
            }
            get has_bool_value() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get int_value() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set int_value(value: number) {
                pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
            }
            get has_int_value() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get typed_value() {
                const cases: {
                    [index: number]: "none" | "bool_value" | "int_value";
                } = {
                    0: "none",
                    2: "bool_value",
                    3: "int_value"
                };
                return cases[pb_1.Message.computeOneofCase(this, [2, 3])];
            }
            static fromObject(data: {
                key?: string;
                bool_value?: boolean;
                int_value?: number;
            }): Attribute {
                const message = new Attribute({});
                if (data.key != null) {
                    message.key = data.key;
                }
                if (data.bool_value != null) {
                    message.bool_value = data.bool_value;
                }
                if (data.int_value != null) {
                    message.int_value = data.int_value;
                }
                return message;
            }
            toObject() {
                const data: {
                    key?: string;
                    bool_value?: boolean;
                    int_value?: number;
                } = {};
                if (this.key != null) {
                    data.key = this.key;
                }
                if (this.bool_value != null) {
                    data.bool_value = this.bool_value;
                }
                if (this.int_value != null) {
                    data.int_value = this.int_value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.key.length)
                    writer.writeString(1, this.key);
                if (this.has_bool_value)
                    writer.writeBool(2, this.bool_value);
                if (this.has_int_value)
                    writer.writeInt64(3, this.int_value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Attribute {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Attribute();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.key = reader.readString();
                            break;
                        case 2:
                            message.bool_value = reader.readBool();
                            break;
                        case 3:
                            message.int_value = reader.readInt64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Attribute {
                return Attribute.deserialize(bytes);
            }
        }
    }
    export class CIDR extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ip?: Uint8Array;
            prefix?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ip" in data && data.ip != undefined) {
                    this.ip = data.ip;
                }
                if ("prefix" in data && data.prefix != undefined) {
                    this.prefix = data.prefix;
                }
            }
        }
        get ip() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set ip(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get prefix() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set prefix(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            ip?: Uint8Array;
            prefix?: number;
        }): CIDR {
            const message = new CIDR({});
            if (data.ip != null) {
                message.ip = data.ip;
            }
            if (data.prefix != null) {
                message.prefix = data.prefix;
            }
            return message;
        }
        toObject() {
            const data: {
                ip?: Uint8Array;
                prefix?: number;
            } = {};
            if (this.ip != null) {
                data.ip = this.ip;
            }
            if (this.prefix != null) {
                data.prefix = this.prefix;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ip.length)
                writer.writeBytes(1, this.ip);
            if (this.prefix != 0)
                writer.writeUint32(2, this.prefix);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CIDR {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CIDR();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ip = reader.readBytes();
                        break;
                    case 2:
                        message.prefix = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CIDR {
            return CIDR.deserialize(bytes);
        }
    }
    export class GeoIP extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            country_code?: string;
            cidr?: CIDR[];
            reverse_match?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("country_code" in data && data.country_code != undefined) {
                    this.country_code = data.country_code;
                }
                if ("cidr" in data && data.cidr != undefined) {
                    this.cidr = data.cidr;
                }
                if ("reverse_match" in data && data.reverse_match != undefined) {
                    this.reverse_match = data.reverse_match;
                }
            }
        }
        get country_code() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set country_code(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get cidr() {
            return pb_1.Message.getRepeatedWrapperField(this, CIDR, 2) as CIDR[];
        }
        set cidr(value: CIDR[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get reverse_match() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set reverse_match(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            country_code?: string;
            cidr?: ReturnType<typeof CIDR.prototype.toObject>[];
            reverse_match?: boolean;
        }): GeoIP {
            const message = new GeoIP({});
            if (data.country_code != null) {
                message.country_code = data.country_code;
            }
            if (data.cidr != null) {
                message.cidr = data.cidr.map(item => CIDR.fromObject(item));
            }
            if (data.reverse_match != null) {
                message.reverse_match = data.reverse_match;
            }
            return message;
        }
        toObject() {
            const data: {
                country_code?: string;
                cidr?: ReturnType<typeof CIDR.prototype.toObject>[];
                reverse_match?: boolean;
            } = {};
            if (this.country_code != null) {
                data.country_code = this.country_code;
            }
            if (this.cidr != null) {
                data.cidr = this.cidr.map((item: CIDR) => item.toObject());
            }
            if (this.reverse_match != null) {
                data.reverse_match = this.reverse_match;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.country_code.length)
                writer.writeString(1, this.country_code);
            if (this.cidr.length)
                writer.writeRepeatedMessage(2, this.cidr, (item: CIDR) => item.serialize(writer));
            if (this.reverse_match != false)
                writer.writeBool(3, this.reverse_match);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeoIP {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeoIP();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.country_code = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.cidr, () => pb_1.Message.addToRepeatedWrapperField(message, 2, CIDR.deserialize(reader), CIDR));
                        break;
                    case 3:
                        message.reverse_match = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GeoIP {
            return GeoIP.deserialize(bytes);
        }
    }
    export class GeoIPList extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            entry?: GeoIP[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("entry" in data && data.entry != undefined) {
                    this.entry = data.entry;
                }
            }
        }
        get entry() {
            return pb_1.Message.getRepeatedWrapperField(this, GeoIP, 1) as GeoIP[];
        }
        set entry(value: GeoIP[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            entry?: ReturnType<typeof GeoIP.prototype.toObject>[];
        }): GeoIPList {
            const message = new GeoIPList({});
            if (data.entry != null) {
                message.entry = data.entry.map(item => GeoIP.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                entry?: ReturnType<typeof GeoIP.prototype.toObject>[];
            } = {};
            if (this.entry != null) {
                data.entry = this.entry.map((item: GeoIP) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.entry.length)
                writer.writeRepeatedMessage(1, this.entry, (item: GeoIP) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeoIPList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeoIPList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.entry, () => pb_1.Message.addToRepeatedWrapperField(message, 1, GeoIP.deserialize(reader), GeoIP));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GeoIPList {
            return GeoIPList.deserialize(bytes);
        }
    }
    export class GeoSite extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            country_code?: string;
            domain?: Domain[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("country_code" in data && data.country_code != undefined) {
                    this.country_code = data.country_code;
                }
                if ("domain" in data && data.domain != undefined) {
                    this.domain = data.domain;
                }
            }
        }
        get country_code() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set country_code(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get domain() {
            return pb_1.Message.getRepeatedWrapperField(this, Domain, 2) as Domain[];
        }
        set domain(value: Domain[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            country_code?: string;
            domain?: ReturnType<typeof Domain.prototype.toObject>[];
        }): GeoSite {
            const message = new GeoSite({});
            if (data.country_code != null) {
                message.country_code = data.country_code;
            }
            if (data.domain != null) {
                message.domain = data.domain.map(item => Domain.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                country_code?: string;
                domain?: ReturnType<typeof Domain.prototype.toObject>[];
            } = {};
            if (this.country_code != null) {
                data.country_code = this.country_code;
            }
            if (this.domain != null) {
                data.domain = this.domain.map((item: Domain) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.country_code.length)
                writer.writeString(1, this.country_code);
            if (this.domain.length)
                writer.writeRepeatedMessage(2, this.domain, (item: Domain) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeoSite {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeoSite();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.country_code = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.domain, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Domain.deserialize(reader), Domain));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GeoSite {
            return GeoSite.deserialize(bytes);
        }
    }
    export class GeoSiteList extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            entry?: GeoSite[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("entry" in data && data.entry != undefined) {
                    this.entry = data.entry;
                }
            }
        }
        get entry() {
            return pb_1.Message.getRepeatedWrapperField(this, GeoSite, 1) as GeoSite[];
        }
        set entry(value: GeoSite[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            entry?: ReturnType<typeof GeoSite.prototype.toObject>[];
        }): GeoSiteList {
            const message = new GeoSiteList({});
            if (data.entry != null) {
                message.entry = data.entry.map(item => GeoSite.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                entry?: ReturnType<typeof GeoSite.prototype.toObject>[];
            } = {};
            if (this.entry != null) {
                data.entry = this.entry.map((item: GeoSite) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.entry.length)
                writer.writeRepeatedMessage(1, this.entry, (item: GeoSite) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeoSiteList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeoSiteList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.entry, () => pb_1.Message.addToRepeatedWrapperField(message, 1, GeoSite.deserialize(reader), GeoSite));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GeoSiteList {
            return GeoSiteList.deserialize(bytes);
        }
    }
    export class RoutingRule extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 12]];
        constructor(data?: any[] | ({
            rule_tag?: string;
            domain?: Domain[];
            geoip?: GeoIP[];
            port_list?: dependency_2.xray.common.net.PortList;
            networks?: dependency_3.xray.common.net.Network[];
            source_geoip?: GeoIP[];
            source_port_list?: dependency_2.xray.common.net.PortList;
            user_email?: string[];
            inbound_tag?: string[];
            protocol?: string[];
            attributes?: Map<string, string>;
            domain_matcher?: string;
        } & (({
            tag?: string;
            balancing_tag?: never;
        } | {
            tag?: never;
            balancing_tag?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 10, 13, 11, 7, 8, 9], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("balancing_tag" in data && data.balancing_tag != undefined) {
                    this.balancing_tag = data.balancing_tag;
                }
                if ("rule_tag" in data && data.rule_tag != undefined) {
                    this.rule_tag = data.rule_tag;
                }
                if ("domain" in data && data.domain != undefined) {
                    this.domain = data.domain;
                }
                if ("geoip" in data && data.geoip != undefined) {
                    this.geoip = data.geoip;
                }
                if ("port_list" in data && data.port_list != undefined) {
                    this.port_list = data.port_list;
                }
                if ("networks" in data && data.networks != undefined) {
                    this.networks = data.networks;
                }
                if ("source_geoip" in data && data.source_geoip != undefined) {
                    this.source_geoip = data.source_geoip;
                }
                if ("source_port_list" in data && data.source_port_list != undefined) {
                    this.source_port_list = data.source_port_list;
                }
                if ("user_email" in data && data.user_email != undefined) {
                    this.user_email = data.user_email;
                }
                if ("inbound_tag" in data && data.inbound_tag != undefined) {
                    this.inbound_tag = data.inbound_tag;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
                if ("domain_matcher" in data && data.domain_matcher != undefined) {
                    this.domain_matcher = data.domain_matcher;
                }
            }
            if (!this.attributes)
                this.attributes = new Map();
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_tag() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get balancing_tag() {
            return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
        }
        set balancing_tag(value: string) {
            pb_1.Message.setOneofField(this, 12, this.#one_of_decls[0], value);
        }
        get has_balancing_tag() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get rule_tag() {
            return pb_1.Message.getFieldWithDefault(this, 18, "") as string;
        }
        set rule_tag(value: string) {
            pb_1.Message.setField(this, 18, value);
        }
        get domain() {
            return pb_1.Message.getRepeatedWrapperField(this, Domain, 2) as Domain[];
        }
        set domain(value: Domain[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get geoip() {
            return pb_1.Message.getRepeatedWrapperField(this, GeoIP, 10) as GeoIP[];
        }
        set geoip(value: GeoIP[]) {
            pb_1.Message.setRepeatedWrapperField(this, 10, value);
        }
        get port_list() {
            return pb_1.Message.getWrapperField(this, dependency_2.xray.common.net.PortList, 14) as dependency_2.xray.common.net.PortList;
        }
        set port_list(value: dependency_2.xray.common.net.PortList) {
            pb_1.Message.setWrapperField(this, 14, value);
        }
        get has_port_list() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get networks() {
            return pb_1.Message.getFieldWithDefault(this, 13, []) as dependency_3.xray.common.net.Network[];
        }
        set networks(value: dependency_3.xray.common.net.Network[]) {
            pb_1.Message.setField(this, 13, value);
        }
        get source_geoip() {
            return pb_1.Message.getRepeatedWrapperField(this, GeoIP, 11) as GeoIP[];
        }
        set source_geoip(value: GeoIP[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        get source_port_list() {
            return pb_1.Message.getWrapperField(this, dependency_2.xray.common.net.PortList, 16) as dependency_2.xray.common.net.PortList;
        }
        set source_port_list(value: dependency_2.xray.common.net.PortList) {
            pb_1.Message.setWrapperField(this, 16, value);
        }
        get has_source_port_list() {
            return pb_1.Message.getField(this, 16) != null;
        }
        get user_email() {
            return pb_1.Message.getFieldWithDefault(this, 7, []) as string[];
        }
        set user_email(value: string[]) {
            pb_1.Message.setField(this, 7, value);
        }
        get inbound_tag() {
            return pb_1.Message.getFieldWithDefault(this, 8, []) as string[];
        }
        set inbound_tag(value: string[]) {
            pb_1.Message.setField(this, 8, value);
        }
        get protocol() {
            return pb_1.Message.getFieldWithDefault(this, 9, []) as string[];
        }
        set protocol(value: string[]) {
            pb_1.Message.setField(this, 9, value);
        }
        get attributes() {
            return pb_1.Message.getField(this, 15) as any as Map<string, string>;
        }
        set attributes(value: Map<string, string>) {
            pb_1.Message.setField(this, 15, value as any);
        }
        get domain_matcher() {
            return pb_1.Message.getFieldWithDefault(this, 17, "") as string;
        }
        set domain_matcher(value: string) {
            pb_1.Message.setField(this, 17, value);
        }
        get target_tag() {
            const cases: {
                [index: number]: "none" | "tag" | "balancing_tag";
            } = {
                0: "none",
                1: "tag",
                12: "balancing_tag"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 12])];
        }
        static fromObject(data: {
            tag?: string;
            balancing_tag?: string;
            rule_tag?: string;
            domain?: ReturnType<typeof Domain.prototype.toObject>[];
            geoip?: ReturnType<typeof GeoIP.prototype.toObject>[];
            port_list?: ReturnType<typeof dependency_2.xray.common.net.PortList.prototype.toObject>;
            networks?: dependency_3.xray.common.net.Network[];
            source_geoip?: ReturnType<typeof GeoIP.prototype.toObject>[];
            source_port_list?: ReturnType<typeof dependency_2.xray.common.net.PortList.prototype.toObject>;
            user_email?: string[];
            inbound_tag?: string[];
            protocol?: string[];
            attributes?: {
                [key: string]: string;
            };
            domain_matcher?: string;
        }): RoutingRule {
            const message = new RoutingRule({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.balancing_tag != null) {
                message.balancing_tag = data.balancing_tag;
            }
            if (data.rule_tag != null) {
                message.rule_tag = data.rule_tag;
            }
            if (data.domain != null) {
                message.domain = data.domain.map(item => Domain.fromObject(item));
            }
            if (data.geoip != null) {
                message.geoip = data.geoip.map(item => GeoIP.fromObject(item));
            }
            if (data.port_list != null) {
                message.port_list = dependency_2.xray.common.net.PortList.fromObject(data.port_list);
            }
            if (data.networks != null) {
                message.networks = data.networks;
            }
            if (data.source_geoip != null) {
                message.source_geoip = data.source_geoip.map(item => GeoIP.fromObject(item));
            }
            if (data.source_port_list != null) {
                message.source_port_list = dependency_2.xray.common.net.PortList.fromObject(data.source_port_list);
            }
            if (data.user_email != null) {
                message.user_email = data.user_email;
            }
            if (data.inbound_tag != null) {
                message.inbound_tag = data.inbound_tag;
            }
            if (data.protocol != null) {
                message.protocol = data.protocol;
            }
            if (typeof data.attributes == "object") {
                message.attributes = new Map(Object.entries(data.attributes));
            }
            if (data.domain_matcher != null) {
                message.domain_matcher = data.domain_matcher;
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string;
                balancing_tag?: string;
                rule_tag?: string;
                domain?: ReturnType<typeof Domain.prototype.toObject>[];
                geoip?: ReturnType<typeof GeoIP.prototype.toObject>[];
                port_list?: ReturnType<typeof dependency_2.xray.common.net.PortList.prototype.toObject>;
                networks?: dependency_3.xray.common.net.Network[];
                source_geoip?: ReturnType<typeof GeoIP.prototype.toObject>[];
                source_port_list?: ReturnType<typeof dependency_2.xray.common.net.PortList.prototype.toObject>;
                user_email?: string[];
                inbound_tag?: string[];
                protocol?: string[];
                attributes?: {
                    [key: string]: string;
                };
                domain_matcher?: string;
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.balancing_tag != null) {
                data.balancing_tag = this.balancing_tag;
            }
            if (this.rule_tag != null) {
                data.rule_tag = this.rule_tag;
            }
            if (this.domain != null) {
                data.domain = this.domain.map((item: Domain) => item.toObject());
            }
            if (this.geoip != null) {
                data.geoip = this.geoip.map((item: GeoIP) => item.toObject());
            }
            if (this.port_list != null) {
                data.port_list = this.port_list.toObject();
            }
            if (this.networks != null) {
                data.networks = this.networks;
            }
            if (this.source_geoip != null) {
                data.source_geoip = this.source_geoip.map((item: GeoIP) => item.toObject());
            }
            if (this.source_port_list != null) {
                data.source_port_list = this.source_port_list.toObject();
            }
            if (this.user_email != null) {
                data.user_email = this.user_email;
            }
            if (this.inbound_tag != null) {
                data.inbound_tag = this.inbound_tag;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.attributes != null) {
                data.attributes = (Object.fromEntries)(this.attributes);
            }
            if (this.domain_matcher != null) {
                data.domain_matcher = this.domain_matcher;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_tag)
                writer.writeString(1, this.tag);
            if (this.has_balancing_tag)
                writer.writeString(12, this.balancing_tag);
            if (this.rule_tag.length)
                writer.writeString(18, this.rule_tag);
            if (this.domain.length)
                writer.writeRepeatedMessage(2, this.domain, (item: Domain) => item.serialize(writer));
            if (this.geoip.length)
                writer.writeRepeatedMessage(10, this.geoip, (item: GeoIP) => item.serialize(writer));
            if (this.has_port_list)
                writer.writeMessage(14, this.port_list, () => this.port_list.serialize(writer));
            if (this.networks.length)
                writer.writePackedEnum(13, this.networks);
            if (this.source_geoip.length)
                writer.writeRepeatedMessage(11, this.source_geoip, (item: GeoIP) => item.serialize(writer));
            if (this.has_source_port_list)
                writer.writeMessage(16, this.source_port_list, () => this.source_port_list.serialize(writer));
            if (this.user_email.length)
                writer.writeRepeatedString(7, this.user_email);
            if (this.inbound_tag.length)
                writer.writeRepeatedString(8, this.inbound_tag);
            if (this.protocol.length)
                writer.writeRepeatedString(9, this.protocol);
            for (const [key, value] of this.attributes) {
                writer.writeMessage(15, this.attributes, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (this.domain_matcher.length)
                writer.writeString(17, this.domain_matcher);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RoutingRule {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RoutingRule();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tag = reader.readString();
                        break;
                    case 12:
                        message.balancing_tag = reader.readString();
                        break;
                    case 18:
                        message.rule_tag = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.domain, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Domain.deserialize(reader), Domain));
                        break;
                    case 10:
                        reader.readMessage(message.geoip, () => pb_1.Message.addToRepeatedWrapperField(message, 10, GeoIP.deserialize(reader), GeoIP));
                        break;
                    case 14:
                        reader.readMessage(message.port_list, () => message.port_list = dependency_2.xray.common.net.PortList.deserialize(reader));
                        break;
                    case 13:
                        message.networks = reader.readPackedEnum();
                        break;
                    case 11:
                        reader.readMessage(message.source_geoip, () => pb_1.Message.addToRepeatedWrapperField(message, 11, GeoIP.deserialize(reader), GeoIP));
                        break;
                    case 16:
                        reader.readMessage(message.source_port_list, () => message.source_port_list = dependency_2.xray.common.net.PortList.deserialize(reader));
                        break;
                    case 7:
                        pb_1.Message.addToRepeatedField(message, 7, reader.readString());
                        break;
                    case 8:
                        pb_1.Message.addToRepeatedField(message, 8, reader.readString());
                        break;
                    case 9:
                        pb_1.Message.addToRepeatedField(message, 9, reader.readString());
                        break;
                    case 15:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.attributes as any, reader, reader.readString, reader.readString));
                        break;
                    case 17:
                        message.domain_matcher = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RoutingRule {
            return RoutingRule.deserialize(bytes);
        }
    }
    export class BalancingRule extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tag?: string;
            outbound_selector?: string[];
            strategy?: string;
            strategy_settings?: dependency_1.xray.common.serial.TypedMessage;
            fallback_tag?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("outbound_selector" in data && data.outbound_selector != undefined) {
                    this.outbound_selector = data.outbound_selector;
                }
                if ("strategy" in data && data.strategy != undefined) {
                    this.strategy = data.strategy;
                }
                if ("strategy_settings" in data && data.strategy_settings != undefined) {
                    this.strategy_settings = data.strategy_settings;
                }
                if ("fallback_tag" in data && data.fallback_tag != undefined) {
                    this.fallback_tag = data.fallback_tag;
                }
            }
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get outbound_selector() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set outbound_selector(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get strategy() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set strategy(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get strategy_settings() {
            return pb_1.Message.getWrapperField(this, dependency_1.xray.common.serial.TypedMessage, 4) as dependency_1.xray.common.serial.TypedMessage;
        }
        set strategy_settings(value: dependency_1.xray.common.serial.TypedMessage) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_strategy_settings() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get fallback_tag() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set fallback_tag(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            tag?: string;
            outbound_selector?: string[];
            strategy?: string;
            strategy_settings?: ReturnType<typeof dependency_1.xray.common.serial.TypedMessage.prototype.toObject>;
            fallback_tag?: string;
        }): BalancingRule {
            const message = new BalancingRule({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.outbound_selector != null) {
                message.outbound_selector = data.outbound_selector;
            }
            if (data.strategy != null) {
                message.strategy = data.strategy;
            }
            if (data.strategy_settings != null) {
                message.strategy_settings = dependency_1.xray.common.serial.TypedMessage.fromObject(data.strategy_settings);
            }
            if (data.fallback_tag != null) {
                message.fallback_tag = data.fallback_tag;
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string;
                outbound_selector?: string[];
                strategy?: string;
                strategy_settings?: ReturnType<typeof dependency_1.xray.common.serial.TypedMessage.prototype.toObject>;
                fallback_tag?: string;
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.outbound_selector != null) {
                data.outbound_selector = this.outbound_selector;
            }
            if (this.strategy != null) {
                data.strategy = this.strategy;
            }
            if (this.strategy_settings != null) {
                data.strategy_settings = this.strategy_settings.toObject();
            }
            if (this.fallback_tag != null) {
                data.fallback_tag = this.fallback_tag;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tag.length)
                writer.writeString(1, this.tag);
            if (this.outbound_selector.length)
                writer.writeRepeatedString(2, this.outbound_selector);
            if (this.strategy.length)
                writer.writeString(3, this.strategy);
            if (this.has_strategy_settings)
                writer.writeMessage(4, this.strategy_settings, () => this.strategy_settings.serialize(writer));
            if (this.fallback_tag.length)
                writer.writeString(5, this.fallback_tag);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BalancingRule {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BalancingRule();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tag = reader.readString();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.strategy = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.strategy_settings, () => message.strategy_settings = dependency_1.xray.common.serial.TypedMessage.deserialize(reader));
                        break;
                    case 5:
                        message.fallback_tag = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BalancingRule {
            return BalancingRule.deserialize(bytes);
        }
    }
    export class StrategyWeight extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            regexp?: boolean;
            match?: string;
            value?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("regexp" in data && data.regexp != undefined) {
                    this.regexp = data.regexp;
                }
                if ("match" in data && data.match != undefined) {
                    this.match = data.match;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get regexp() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set regexp(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get match() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set match(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            regexp?: boolean;
            match?: string;
            value?: number;
        }): StrategyWeight {
            const message = new StrategyWeight({});
            if (data.regexp != null) {
                message.regexp = data.regexp;
            }
            if (data.match != null) {
                message.match = data.match;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                regexp?: boolean;
                match?: string;
                value?: number;
            } = {};
            if (this.regexp != null) {
                data.regexp = this.regexp;
            }
            if (this.match != null) {
                data.match = this.match;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.regexp != false)
                writer.writeBool(1, this.regexp);
            if (this.match.length)
                writer.writeString(2, this.match);
            if (this.value != 0)
                writer.writeFloat(3, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StrategyWeight {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StrategyWeight();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.regexp = reader.readBool();
                        break;
                    case 2:
                        message.match = reader.readString();
                        break;
                    case 3:
                        message.value = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StrategyWeight {
            return StrategyWeight.deserialize(bytes);
        }
    }
    export class StrategyLeastLoadConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            costs?: StrategyWeight[];
            baselines?: number[];
            expected?: number;
            maxRTT?: number;
            tolerance?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("costs" in data && data.costs != undefined) {
                    this.costs = data.costs;
                }
                if ("baselines" in data && data.baselines != undefined) {
                    this.baselines = data.baselines;
                }
                if ("expected" in data && data.expected != undefined) {
                    this.expected = data.expected;
                }
                if ("maxRTT" in data && data.maxRTT != undefined) {
                    this.maxRTT = data.maxRTT;
                }
                if ("tolerance" in data && data.tolerance != undefined) {
                    this.tolerance = data.tolerance;
                }
            }
        }
        get costs() {
            return pb_1.Message.getRepeatedWrapperField(this, StrategyWeight, 2) as StrategyWeight[];
        }
        set costs(value: StrategyWeight[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get baselines() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
        }
        set baselines(value: number[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get expected() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set expected(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get maxRTT() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set maxRTT(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get tolerance() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set tolerance(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            costs?: ReturnType<typeof StrategyWeight.prototype.toObject>[];
            baselines?: number[];
            expected?: number;
            maxRTT?: number;
            tolerance?: number;
        }): StrategyLeastLoadConfig {
            const message = new StrategyLeastLoadConfig({});
            if (data.costs != null) {
                message.costs = data.costs.map(item => StrategyWeight.fromObject(item));
            }
            if (data.baselines != null) {
                message.baselines = data.baselines;
            }
            if (data.expected != null) {
                message.expected = data.expected;
            }
            if (data.maxRTT != null) {
                message.maxRTT = data.maxRTT;
            }
            if (data.tolerance != null) {
                message.tolerance = data.tolerance;
            }
            return message;
        }
        toObject() {
            const data: {
                costs?: ReturnType<typeof StrategyWeight.prototype.toObject>[];
                baselines?: number[];
                expected?: number;
                maxRTT?: number;
                tolerance?: number;
            } = {};
            if (this.costs != null) {
                data.costs = this.costs.map((item: StrategyWeight) => item.toObject());
            }
            if (this.baselines != null) {
                data.baselines = this.baselines;
            }
            if (this.expected != null) {
                data.expected = this.expected;
            }
            if (this.maxRTT != null) {
                data.maxRTT = this.maxRTT;
            }
            if (this.tolerance != null) {
                data.tolerance = this.tolerance;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.costs.length)
                writer.writeRepeatedMessage(2, this.costs, (item: StrategyWeight) => item.serialize(writer));
            if (this.baselines.length)
                writer.writePackedInt64(3, this.baselines);
            if (this.expected != 0)
                writer.writeInt32(4, this.expected);
            if (this.maxRTT != 0)
                writer.writeInt64(5, this.maxRTT);
            if (this.tolerance != 0)
                writer.writeFloat(6, this.tolerance);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StrategyLeastLoadConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StrategyLeastLoadConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        reader.readMessage(message.costs, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StrategyWeight.deserialize(reader), StrategyWeight));
                        break;
                    case 3:
                        message.baselines = reader.readPackedInt64();
                        break;
                    case 4:
                        message.expected = reader.readInt32();
                        break;
                    case 5:
                        message.maxRTT = reader.readInt64();
                        break;
                    case 6:
                        message.tolerance = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StrategyLeastLoadConfig {
            return StrategyLeastLoadConfig.deserialize(bytes);
        }
    }
    export class Config extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            domain_strategy?: Config.DomainStrategy;
            rule?: RoutingRule[];
            balancing_rule?: BalancingRule[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("domain_strategy" in data && data.domain_strategy != undefined) {
                    this.domain_strategy = data.domain_strategy;
                }
                if ("rule" in data && data.rule != undefined) {
                    this.rule = data.rule;
                }
                if ("balancing_rule" in data && data.balancing_rule != undefined) {
                    this.balancing_rule = data.balancing_rule;
                }
            }
        }
        get domain_strategy() {
            return pb_1.Message.getFieldWithDefault(this, 1, Config.DomainStrategy.AsIs) as Config.DomainStrategy;
        }
        set domain_strategy(value: Config.DomainStrategy) {
            pb_1.Message.setField(this, 1, value);
        }
        get rule() {
            return pb_1.Message.getRepeatedWrapperField(this, RoutingRule, 2) as RoutingRule[];
        }
        set rule(value: RoutingRule[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get balancing_rule() {
            return pb_1.Message.getRepeatedWrapperField(this, BalancingRule, 3) as BalancingRule[];
        }
        set balancing_rule(value: BalancingRule[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            domain_strategy?: Config.DomainStrategy;
            rule?: ReturnType<typeof RoutingRule.prototype.toObject>[];
            balancing_rule?: ReturnType<typeof BalancingRule.prototype.toObject>[];
        }): Config {
            const message = new Config({});
            if (data.domain_strategy != null) {
                message.domain_strategy = data.domain_strategy;
            }
            if (data.rule != null) {
                message.rule = data.rule.map(item => RoutingRule.fromObject(item));
            }
            if (data.balancing_rule != null) {
                message.balancing_rule = data.balancing_rule.map(item => BalancingRule.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                domain_strategy?: Config.DomainStrategy;
                rule?: ReturnType<typeof RoutingRule.prototype.toObject>[];
                balancing_rule?: ReturnType<typeof BalancingRule.prototype.toObject>[];
            } = {};
            if (this.domain_strategy != null) {
                data.domain_strategy = this.domain_strategy;
            }
            if (this.rule != null) {
                data.rule = this.rule.map((item: RoutingRule) => item.toObject());
            }
            if (this.balancing_rule != null) {
                data.balancing_rule = this.balancing_rule.map((item: BalancingRule) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.domain_strategy != Config.DomainStrategy.AsIs)
                writer.writeEnum(1, this.domain_strategy);
            if (this.rule.length)
                writer.writeRepeatedMessage(2, this.rule, (item: RoutingRule) => item.serialize(writer));
            if (this.balancing_rule.length)
                writer.writeRepeatedMessage(3, this.balancing_rule, (item: BalancingRule) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Config {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Config();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.domain_strategy = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.rule, () => pb_1.Message.addToRepeatedWrapperField(message, 2, RoutingRule.deserialize(reader), RoutingRule));
                        break;
                    case 3:
                        reader.readMessage(message.balancing_rule, () => pb_1.Message.addToRepeatedWrapperField(message, 3, BalancingRule.deserialize(reader), BalancingRule));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Config {
            return Config.deserialize(bytes);
        }
    }
    export namespace Config {
        export enum DomainStrategy {
            AsIs = 0,
            UseIp = 1,
            IpIfNonMatch = 2,
            IpOnDemand = 3
        }
    }
}
