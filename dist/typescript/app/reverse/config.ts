/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: app/reverse/config.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace xray.app.reverse {
    export class Control extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            state?: Control.State;
            random?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("random" in data && data.random != undefined) {
                    this.random = data.random;
                }
            }
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 1, Control.State.ACTIVE) as Control.State;
        }
        set state(value: Control.State) {
            pb_1.Message.setField(this, 1, value);
        }
        get random() {
            return pb_1.Message.getFieldWithDefault(this, 99, new Uint8Array(0)) as Uint8Array;
        }
        set random(value: Uint8Array) {
            pb_1.Message.setField(this, 99, value);
        }
        static fromObject(data: {
            state?: Control.State;
            random?: Uint8Array;
        }): Control {
            const message = new Control({});
            if (data.state != null) {
                message.state = data.state;
            }
            if (data.random != null) {
                message.random = data.random;
            }
            return message;
        }
        toObject() {
            const data: {
                state?: Control.State;
                random?: Uint8Array;
            } = {};
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.random != null) {
                data.random = this.random;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.state != Control.State.ACTIVE)
                writer.writeEnum(1, this.state);
            if (this.random.length)
                writer.writeBytes(99, this.random);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Control {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Control();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.state = reader.readEnum();
                        break;
                    case 99:
                        message.random = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Control {
            return Control.deserialize(bytes);
        }
    }
    export namespace Control {
        export enum State {
            ACTIVE = 0,
            DRAIN = 1
        }
    }
    export class BridgeConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tag?: string;
            domain?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("domain" in data && data.domain != undefined) {
                    this.domain = data.domain;
                }
            }
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get domain() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set domain(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            tag?: string;
            domain?: string;
        }): BridgeConfig {
            const message = new BridgeConfig({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.domain != null) {
                message.domain = data.domain;
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string;
                domain?: string;
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.domain != null) {
                data.domain = this.domain;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tag.length)
                writer.writeString(1, this.tag);
            if (this.domain.length)
                writer.writeString(2, this.domain);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BridgeConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BridgeConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tag = reader.readString();
                        break;
                    case 2:
                        message.domain = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BridgeConfig {
            return BridgeConfig.deserialize(bytes);
        }
    }
    export class PortalConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tag?: string;
            domain?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("domain" in data && data.domain != undefined) {
                    this.domain = data.domain;
                }
            }
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get domain() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set domain(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            tag?: string;
            domain?: string;
        }): PortalConfig {
            const message = new PortalConfig({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.domain != null) {
                message.domain = data.domain;
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string;
                domain?: string;
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.domain != null) {
                data.domain = this.domain;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tag.length)
                writer.writeString(1, this.tag);
            if (this.domain.length)
                writer.writeString(2, this.domain);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PortalConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PortalConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tag = reader.readString();
                        break;
                    case 2:
                        message.domain = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PortalConfig {
            return PortalConfig.deserialize(bytes);
        }
    }
    export class Config extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            bridge_config?: BridgeConfig[];
            portal_config?: PortalConfig[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("bridge_config" in data && data.bridge_config != undefined) {
                    this.bridge_config = data.bridge_config;
                }
                if ("portal_config" in data && data.portal_config != undefined) {
                    this.portal_config = data.portal_config;
                }
            }
        }
        get bridge_config() {
            return pb_1.Message.getRepeatedWrapperField(this, BridgeConfig, 1) as BridgeConfig[];
        }
        set bridge_config(value: BridgeConfig[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get portal_config() {
            return pb_1.Message.getRepeatedWrapperField(this, PortalConfig, 2) as PortalConfig[];
        }
        set portal_config(value: PortalConfig[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            bridge_config?: ReturnType<typeof BridgeConfig.prototype.toObject>[];
            portal_config?: ReturnType<typeof PortalConfig.prototype.toObject>[];
        }): Config {
            const message = new Config({});
            if (data.bridge_config != null) {
                message.bridge_config = data.bridge_config.map(item => BridgeConfig.fromObject(item));
            }
            if (data.portal_config != null) {
                message.portal_config = data.portal_config.map(item => PortalConfig.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                bridge_config?: ReturnType<typeof BridgeConfig.prototype.toObject>[];
                portal_config?: ReturnType<typeof PortalConfig.prototype.toObject>[];
            } = {};
            if (this.bridge_config != null) {
                data.bridge_config = this.bridge_config.map((item: BridgeConfig) => item.toObject());
            }
            if (this.portal_config != null) {
                data.portal_config = this.portal_config.map((item: PortalConfig) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.bridge_config.length)
                writer.writeRepeatedMessage(1, this.bridge_config, (item: BridgeConfig) => item.serialize(writer));
            if (this.portal_config.length)
                writer.writeRepeatedMessage(2, this.portal_config, (item: PortalConfig) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Config {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Config();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.bridge_config, () => pb_1.Message.addToRepeatedWrapperField(message, 1, BridgeConfig.deserialize(reader), BridgeConfig));
                        break;
                    case 2:
                        reader.readMessage(message.portal_config, () => pb_1.Message.addToRepeatedWrapperField(message, 2, PortalConfig.deserialize(reader), PortalConfig));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Config {
            return Config.deserialize(bytes);
        }
    }
}
