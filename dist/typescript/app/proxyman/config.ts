// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.3
//   protoc               v6.31.1
// source: app/proxyman/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { IPOrDomain } from "../../common/net/address";
import { PortList } from "../../common/net/port";
import { TypedMessage } from "../../common/serial/typed_message";
import { ProxyConfig, StreamConfig } from "../../transport/internet/config";

export const protobufPackage = "xray.app.proxyman";

export interface InboundConfig {
}

export interface AllocationStrategy {
  type: AllocationStrategy_Type;
  /**
   * Number of handlers (ports) running in parallel.
   * Default value is 3 if unset.
   */
  concurrency:
    | AllocationStrategy_AllocationStrategyConcurrency
    | undefined;
  /**
   * Number of minutes before a handler is regenerated.
   * Default value is 5 if unset.
   */
  refresh: AllocationStrategy_AllocationStrategyRefresh | undefined;
}

export enum AllocationStrategy_Type {
  /** Always - Always allocate all connection handlers. */
  Always = 0,
  /** Random - Randomly allocate specific range of handlers. */
  Random = 1,
  /** External - External. Not supported yet. */
  External = 2,
  UNRECOGNIZED = -1,
}

export function allocationStrategy_TypeFromJSON(object: any): AllocationStrategy_Type {
  switch (object) {
    case 0:
    case "Always":
      return AllocationStrategy_Type.Always;
    case 1:
    case "Random":
      return AllocationStrategy_Type.Random;
    case 2:
    case "External":
      return AllocationStrategy_Type.External;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllocationStrategy_Type.UNRECOGNIZED;
  }
}

export function allocationStrategy_TypeToJSON(object: AllocationStrategy_Type): string {
  switch (object) {
    case AllocationStrategy_Type.Always:
      return "Always";
    case AllocationStrategy_Type.Random:
      return "Random";
    case AllocationStrategy_Type.External:
      return "External";
    case AllocationStrategy_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AllocationStrategy_AllocationStrategyConcurrency {
  value: number;
}

export interface AllocationStrategy_AllocationStrategyRefresh {
  value: number;
}

export interface SniffingConfig {
  /** Whether or not to enable content sniffing on an inbound connection. */
  enabled: boolean;
  /**
   * Override target destination if sniff'ed protocol is in the given list.
   * Supported values are "http", "tls", "fakedns".
   */
  destinationOverride: string[];
  domainsExcluded: string[];
  /**
   * Whether should only try to sniff metadata without waiting for client input.
   * Can be used to support SMTP like protocol where server send the first
   * message.
   */
  metadataOnly: boolean;
  routeOnly: boolean;
}

export interface ReceiverConfig {
  /** PortList specifies the ports which the Receiver should listen on. */
  portList:
    | PortList
    | undefined;
  /** Listen specifies the IP address that the Receiver should listen on. */
  listen: IPOrDomain | undefined;
  allocationStrategy: AllocationStrategy | undefined;
  streamSettings: StreamConfig | undefined;
  receiveOriginalDestination: boolean;
  sniffingSettings: SniffingConfig | undefined;
}

export interface InboundHandlerConfig {
  tag: string;
  receiverSettings: TypedMessage | undefined;
  proxySettings: TypedMessage | undefined;
}

export interface OutboundConfig {
}

export interface SenderConfig {
  /** Send traffic through the given IP. Only IP is allowed. */
  via: IPOrDomain | undefined;
  streamSettings: StreamConfig | undefined;
  proxySettings: ProxyConfig | undefined;
  multiplexSettings: MultiplexingConfig | undefined;
  viaCidr: string;
}

export interface MultiplexingConfig {
  /** Whether or not Mux is enabled. */
  enabled: boolean;
  /** Max number of concurrent connections that one Mux connection can handle. */
  concurrency: number;
  /** Transport XUDP in another Mux. */
  xudpConcurrency: number;
  /** "reject" (default), "allow" or "skip". */
  xudpProxyUDP443: string;
}

function createBaseInboundConfig(): InboundConfig {
  return {};
}

export const InboundConfig: MessageFns<InboundConfig> = {
  encode(_: InboundConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InboundConfig {
    return {};
  },

  toJSON(_: InboundConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InboundConfig>, I>>(base?: I): InboundConfig {
    return InboundConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InboundConfig>, I>>(_: I): InboundConfig {
    const message = createBaseInboundConfig();
    return message;
  },
};

function createBaseAllocationStrategy(): AllocationStrategy {
  return { type: 0, concurrency: undefined, refresh: undefined };
}

export const AllocationStrategy: MessageFns<AllocationStrategy> = {
  encode(message: AllocationStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.concurrency !== undefined) {
      AllocationStrategy_AllocationStrategyConcurrency.encode(message.concurrency, writer.uint32(18).fork()).join();
    }
    if (message.refresh !== undefined) {
      AllocationStrategy_AllocationStrategyRefresh.encode(message.refresh, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.concurrency = AllocationStrategy_AllocationStrategyConcurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refresh = AllocationStrategy_AllocationStrategyRefresh.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationStrategy {
    return {
      type: isSet(object.type) ? allocationStrategy_TypeFromJSON(object.type) : 0,
      concurrency: isSet(object.concurrency)
        ? AllocationStrategy_AllocationStrategyConcurrency.fromJSON(object.concurrency)
        : undefined,
      refresh: isSet(object.refresh)
        ? AllocationStrategy_AllocationStrategyRefresh.fromJSON(object.refresh)
        : undefined,
    };
  },

  toJSON(message: AllocationStrategy): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = allocationStrategy_TypeToJSON(message.type);
    }
    if (message.concurrency !== undefined) {
      obj.concurrency = AllocationStrategy_AllocationStrategyConcurrency.toJSON(message.concurrency);
    }
    if (message.refresh !== undefined) {
      obj.refresh = AllocationStrategy_AllocationStrategyRefresh.toJSON(message.refresh);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationStrategy>, I>>(base?: I): AllocationStrategy {
    return AllocationStrategy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllocationStrategy>, I>>(object: I): AllocationStrategy {
    const message = createBaseAllocationStrategy();
    message.type = object.type ?? 0;
    message.concurrency = (object.concurrency !== undefined && object.concurrency !== null)
      ? AllocationStrategy_AllocationStrategyConcurrency.fromPartial(object.concurrency)
      : undefined;
    message.refresh = (object.refresh !== undefined && object.refresh !== null)
      ? AllocationStrategy_AllocationStrategyRefresh.fromPartial(object.refresh)
      : undefined;
    return message;
  },
};

function createBaseAllocationStrategy_AllocationStrategyConcurrency(): AllocationStrategy_AllocationStrategyConcurrency {
  return { value: 0 };
}

export const AllocationStrategy_AllocationStrategyConcurrency: MessageFns<
  AllocationStrategy_AllocationStrategyConcurrency
> = {
  encode(
    message: AllocationStrategy_AllocationStrategyConcurrency,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationStrategy_AllocationStrategyConcurrency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationStrategy_AllocationStrategyConcurrency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationStrategy_AllocationStrategyConcurrency {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: AllocationStrategy_AllocationStrategyConcurrency): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationStrategy_AllocationStrategyConcurrency>, I>>(
    base?: I,
  ): AllocationStrategy_AllocationStrategyConcurrency {
    return AllocationStrategy_AllocationStrategyConcurrency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllocationStrategy_AllocationStrategyConcurrency>, I>>(
    object: I,
  ): AllocationStrategy_AllocationStrategyConcurrency {
    const message = createBaseAllocationStrategy_AllocationStrategyConcurrency();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAllocationStrategy_AllocationStrategyRefresh(): AllocationStrategy_AllocationStrategyRefresh {
  return { value: 0 };
}

export const AllocationStrategy_AllocationStrategyRefresh: MessageFns<AllocationStrategy_AllocationStrategyRefresh> = {
  encode(
    message: AllocationStrategy_AllocationStrategyRefresh,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationStrategy_AllocationStrategyRefresh {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationStrategy_AllocationStrategyRefresh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationStrategy_AllocationStrategyRefresh {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: AllocationStrategy_AllocationStrategyRefresh): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationStrategy_AllocationStrategyRefresh>, I>>(
    base?: I,
  ): AllocationStrategy_AllocationStrategyRefresh {
    return AllocationStrategy_AllocationStrategyRefresh.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllocationStrategy_AllocationStrategyRefresh>, I>>(
    object: I,
  ): AllocationStrategy_AllocationStrategyRefresh {
    const message = createBaseAllocationStrategy_AllocationStrategyRefresh();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSniffingConfig(): SniffingConfig {
  return { enabled: false, destinationOverride: [], domainsExcluded: [], metadataOnly: false, routeOnly: false };
}

export const SniffingConfig: MessageFns<SniffingConfig> = {
  encode(message: SniffingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.destinationOverride) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.domainsExcluded) {
      writer.uint32(26).string(v!);
    }
    if (message.metadataOnly !== false) {
      writer.uint32(32).bool(message.metadataOnly);
    }
    if (message.routeOnly !== false) {
      writer.uint32(40).bool(message.routeOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SniffingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSniffingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destinationOverride.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.domainsExcluded.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.metadataOnly = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.routeOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SniffingConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      destinationOverride: globalThis.Array.isArray(object?.destinationOverride)
        ? object.destinationOverride.map((e: any) => globalThis.String(e))
        : [],
      domainsExcluded: globalThis.Array.isArray(object?.domainsExcluded)
        ? object.domainsExcluded.map((e: any) => globalThis.String(e))
        : [],
      metadataOnly: isSet(object.metadataOnly) ? globalThis.Boolean(object.metadataOnly) : false,
      routeOnly: isSet(object.routeOnly) ? globalThis.Boolean(object.routeOnly) : false,
    };
  },

  toJSON(message: SniffingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.destinationOverride?.length) {
      obj.destinationOverride = message.destinationOverride;
    }
    if (message.domainsExcluded?.length) {
      obj.domainsExcluded = message.domainsExcluded;
    }
    if (message.metadataOnly !== false) {
      obj.metadataOnly = message.metadataOnly;
    }
    if (message.routeOnly !== false) {
      obj.routeOnly = message.routeOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SniffingConfig>, I>>(base?: I): SniffingConfig {
    return SniffingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SniffingConfig>, I>>(object: I): SniffingConfig {
    const message = createBaseSniffingConfig();
    message.enabled = object.enabled ?? false;
    message.destinationOverride = object.destinationOverride?.map((e) => e) || [];
    message.domainsExcluded = object.domainsExcluded?.map((e) => e) || [];
    message.metadataOnly = object.metadataOnly ?? false;
    message.routeOnly = object.routeOnly ?? false;
    return message;
  },
};

function createBaseReceiverConfig(): ReceiverConfig {
  return {
    portList: undefined,
    listen: undefined,
    allocationStrategy: undefined,
    streamSettings: undefined,
    receiveOriginalDestination: false,
    sniffingSettings: undefined,
  };
}

export const ReceiverConfig: MessageFns<ReceiverConfig> = {
  encode(message: ReceiverConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portList !== undefined) {
      PortList.encode(message.portList, writer.uint32(10).fork()).join();
    }
    if (message.listen !== undefined) {
      IPOrDomain.encode(message.listen, writer.uint32(18).fork()).join();
    }
    if (message.allocationStrategy !== undefined) {
      AllocationStrategy.encode(message.allocationStrategy, writer.uint32(26).fork()).join();
    }
    if (message.streamSettings !== undefined) {
      StreamConfig.encode(message.streamSettings, writer.uint32(34).fork()).join();
    }
    if (message.receiveOriginalDestination !== false) {
      writer.uint32(40).bool(message.receiveOriginalDestination);
    }
    if (message.sniffingSettings !== undefined) {
      SniffingConfig.encode(message.sniffingSettings, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiverConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portList = PortList.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.listen = IPOrDomain.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allocationStrategy = AllocationStrategy.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.streamSettings = StreamConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.receiveOriginalDestination = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sniffingSettings = SniffingConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiverConfig {
    return {
      portList: isSet(object.portList) ? PortList.fromJSON(object.portList) : undefined,
      listen: isSet(object.listen) ? IPOrDomain.fromJSON(object.listen) : undefined,
      allocationStrategy: isSet(object.allocationStrategy)
        ? AllocationStrategy.fromJSON(object.allocationStrategy)
        : undefined,
      streamSettings: isSet(object.streamSettings) ? StreamConfig.fromJSON(object.streamSettings) : undefined,
      receiveOriginalDestination: isSet(object.receiveOriginalDestination)
        ? globalThis.Boolean(object.receiveOriginalDestination)
        : false,
      sniffingSettings: isSet(object.sniffingSettings) ? SniffingConfig.fromJSON(object.sniffingSettings) : undefined,
    };
  },

  toJSON(message: ReceiverConfig): unknown {
    const obj: any = {};
    if (message.portList !== undefined) {
      obj.portList = PortList.toJSON(message.portList);
    }
    if (message.listen !== undefined) {
      obj.listen = IPOrDomain.toJSON(message.listen);
    }
    if (message.allocationStrategy !== undefined) {
      obj.allocationStrategy = AllocationStrategy.toJSON(message.allocationStrategy);
    }
    if (message.streamSettings !== undefined) {
      obj.streamSettings = StreamConfig.toJSON(message.streamSettings);
    }
    if (message.receiveOriginalDestination !== false) {
      obj.receiveOriginalDestination = message.receiveOriginalDestination;
    }
    if (message.sniffingSettings !== undefined) {
      obj.sniffingSettings = SniffingConfig.toJSON(message.sniffingSettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiverConfig>, I>>(base?: I): ReceiverConfig {
    return ReceiverConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiverConfig>, I>>(object: I): ReceiverConfig {
    const message = createBaseReceiverConfig();
    message.portList = (object.portList !== undefined && object.portList !== null)
      ? PortList.fromPartial(object.portList)
      : undefined;
    message.listen = (object.listen !== undefined && object.listen !== null)
      ? IPOrDomain.fromPartial(object.listen)
      : undefined;
    message.allocationStrategy = (object.allocationStrategy !== undefined && object.allocationStrategy !== null)
      ? AllocationStrategy.fromPartial(object.allocationStrategy)
      : undefined;
    message.streamSettings = (object.streamSettings !== undefined && object.streamSettings !== null)
      ? StreamConfig.fromPartial(object.streamSettings)
      : undefined;
    message.receiveOriginalDestination = object.receiveOriginalDestination ?? false;
    message.sniffingSettings = (object.sniffingSettings !== undefined && object.sniffingSettings !== null)
      ? SniffingConfig.fromPartial(object.sniffingSettings)
      : undefined;
    return message;
  },
};

function createBaseInboundHandlerConfig(): InboundHandlerConfig {
  return { tag: "", receiverSettings: undefined, proxySettings: undefined };
}

export const InboundHandlerConfig: MessageFns<InboundHandlerConfig> = {
  encode(message: InboundHandlerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.receiverSettings !== undefined) {
      TypedMessage.encode(message.receiverSettings, writer.uint32(18).fork()).join();
    }
    if (message.proxySettings !== undefined) {
      TypedMessage.encode(message.proxySettings, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundHandlerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundHandlerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receiverSettings = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proxySettings = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundHandlerConfig {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      receiverSettings: isSet(object.receiverSettings) ? TypedMessage.fromJSON(object.receiverSettings) : undefined,
      proxySettings: isSet(object.proxySettings) ? TypedMessage.fromJSON(object.proxySettings) : undefined,
    };
  },

  toJSON(message: InboundHandlerConfig): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.receiverSettings !== undefined) {
      obj.receiverSettings = TypedMessage.toJSON(message.receiverSettings);
    }
    if (message.proxySettings !== undefined) {
      obj.proxySettings = TypedMessage.toJSON(message.proxySettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InboundHandlerConfig>, I>>(base?: I): InboundHandlerConfig {
    return InboundHandlerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InboundHandlerConfig>, I>>(object: I): InboundHandlerConfig {
    const message = createBaseInboundHandlerConfig();
    message.tag = object.tag ?? "";
    message.receiverSettings = (object.receiverSettings !== undefined && object.receiverSettings !== null)
      ? TypedMessage.fromPartial(object.receiverSettings)
      : undefined;
    message.proxySettings = (object.proxySettings !== undefined && object.proxySettings !== null)
      ? TypedMessage.fromPartial(object.proxySettings)
      : undefined;
    return message;
  },
};

function createBaseOutboundConfig(): OutboundConfig {
  return {};
}

export const OutboundConfig: MessageFns<OutboundConfig> = {
  encode(_: OutboundConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OutboundConfig {
    return {};
  },

  toJSON(_: OutboundConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OutboundConfig>, I>>(base?: I): OutboundConfig {
    return OutboundConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutboundConfig>, I>>(_: I): OutboundConfig {
    const message = createBaseOutboundConfig();
    return message;
  },
};

function createBaseSenderConfig(): SenderConfig {
  return {
    via: undefined,
    streamSettings: undefined,
    proxySettings: undefined,
    multiplexSettings: undefined,
    viaCidr: "",
  };
}

export const SenderConfig: MessageFns<SenderConfig> = {
  encode(message: SenderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.via !== undefined) {
      IPOrDomain.encode(message.via, writer.uint32(10).fork()).join();
    }
    if (message.streamSettings !== undefined) {
      StreamConfig.encode(message.streamSettings, writer.uint32(18).fork()).join();
    }
    if (message.proxySettings !== undefined) {
      ProxyConfig.encode(message.proxySettings, writer.uint32(26).fork()).join();
    }
    if (message.multiplexSettings !== undefined) {
      MultiplexingConfig.encode(message.multiplexSettings, writer.uint32(34).fork()).join();
    }
    if (message.viaCidr !== "") {
      writer.uint32(42).string(message.viaCidr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.via = IPOrDomain.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamSettings = StreamConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proxySettings = ProxyConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.multiplexSettings = MultiplexingConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viaCidr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderConfig {
    return {
      via: isSet(object.via) ? IPOrDomain.fromJSON(object.via) : undefined,
      streamSettings: isSet(object.streamSettings) ? StreamConfig.fromJSON(object.streamSettings) : undefined,
      proxySettings: isSet(object.proxySettings) ? ProxyConfig.fromJSON(object.proxySettings) : undefined,
      multiplexSettings: isSet(object.multiplexSettings)
        ? MultiplexingConfig.fromJSON(object.multiplexSettings)
        : undefined,
      viaCidr: isSet(object.viaCidr) ? globalThis.String(object.viaCidr) : "",
    };
  },

  toJSON(message: SenderConfig): unknown {
    const obj: any = {};
    if (message.via !== undefined) {
      obj.via = IPOrDomain.toJSON(message.via);
    }
    if (message.streamSettings !== undefined) {
      obj.streamSettings = StreamConfig.toJSON(message.streamSettings);
    }
    if (message.proxySettings !== undefined) {
      obj.proxySettings = ProxyConfig.toJSON(message.proxySettings);
    }
    if (message.multiplexSettings !== undefined) {
      obj.multiplexSettings = MultiplexingConfig.toJSON(message.multiplexSettings);
    }
    if (message.viaCidr !== "") {
      obj.viaCidr = message.viaCidr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SenderConfig>, I>>(base?: I): SenderConfig {
    return SenderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SenderConfig>, I>>(object: I): SenderConfig {
    const message = createBaseSenderConfig();
    message.via = (object.via !== undefined && object.via !== null) ? IPOrDomain.fromPartial(object.via) : undefined;
    message.streamSettings = (object.streamSettings !== undefined && object.streamSettings !== null)
      ? StreamConfig.fromPartial(object.streamSettings)
      : undefined;
    message.proxySettings = (object.proxySettings !== undefined && object.proxySettings !== null)
      ? ProxyConfig.fromPartial(object.proxySettings)
      : undefined;
    message.multiplexSettings = (object.multiplexSettings !== undefined && object.multiplexSettings !== null)
      ? MultiplexingConfig.fromPartial(object.multiplexSettings)
      : undefined;
    message.viaCidr = object.viaCidr ?? "";
    return message;
  },
};

function createBaseMultiplexingConfig(): MultiplexingConfig {
  return { enabled: false, concurrency: 0, xudpConcurrency: 0, xudpProxyUDP443: "" };
}

export const MultiplexingConfig: MessageFns<MultiplexingConfig> = {
  encode(message: MultiplexingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.concurrency !== 0) {
      writer.uint32(16).int32(message.concurrency);
    }
    if (message.xudpConcurrency !== 0) {
      writer.uint32(24).int32(message.xudpConcurrency);
    }
    if (message.xudpProxyUDP443 !== "") {
      writer.uint32(34).string(message.xudpProxyUDP443);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiplexingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiplexingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.concurrency = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.xudpConcurrency = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.xudpProxyUDP443 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiplexingConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      concurrency: isSet(object.concurrency) ? globalThis.Number(object.concurrency) : 0,
      xudpConcurrency: isSet(object.xudpConcurrency) ? globalThis.Number(object.xudpConcurrency) : 0,
      xudpProxyUDP443: isSet(object.xudpProxyUDP443) ? globalThis.String(object.xudpProxyUDP443) : "",
    };
  },

  toJSON(message: MultiplexingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.concurrency !== 0) {
      obj.concurrency = Math.round(message.concurrency);
    }
    if (message.xudpConcurrency !== 0) {
      obj.xudpConcurrency = Math.round(message.xudpConcurrency);
    }
    if (message.xudpProxyUDP443 !== "") {
      obj.xudpProxyUDP443 = message.xudpProxyUDP443;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiplexingConfig>, I>>(base?: I): MultiplexingConfig {
    return MultiplexingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiplexingConfig>, I>>(object: I): MultiplexingConfig {
    const message = createBaseMultiplexingConfig();
    message.enabled = object.enabled ?? false;
    message.concurrency = object.concurrency ?? 0;
    message.xudpConcurrency = object.xudpConcurrency ?? 0;
    message.xudpProxyUDP443 = object.xudpProxyUDP443 ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
