/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: app/proxyman/config.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../common/net/address";
import * as dependency_2 from "./../../common/net/port";
import * as dependency_3 from "./../../transport/internet/config";
import * as dependency_4 from "./../../common/serial/typed_message";
import * as pb_1 from "google-protobuf";
export namespace xray.app.proxyman {
    export class InboundConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): InboundConfig {
            const message = new InboundConfig({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InboundConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InboundConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InboundConfig {
            return InboundConfig.deserialize(bytes);
        }
    }
    export class AllocationStrategy extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: AllocationStrategy.Type;
            concurrency?: AllocationStrategy.AllocationStrategyConcurrency;
            refresh?: AllocationStrategy.AllocationStrategyRefresh;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("concurrency" in data && data.concurrency != undefined) {
                    this.concurrency = data.concurrency;
                }
                if ("refresh" in data && data.refresh != undefined) {
                    this.refresh = data.refresh;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, AllocationStrategy.Type.Always) as AllocationStrategy.Type;
        }
        set type(value: AllocationStrategy.Type) {
            pb_1.Message.setField(this, 1, value);
        }
        get concurrency() {
            return pb_1.Message.getWrapperField(this, AllocationStrategy.AllocationStrategyConcurrency, 2) as AllocationStrategy.AllocationStrategyConcurrency;
        }
        set concurrency(value: AllocationStrategy.AllocationStrategyConcurrency) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_concurrency() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get refresh() {
            return pb_1.Message.getWrapperField(this, AllocationStrategy.AllocationStrategyRefresh, 3) as AllocationStrategy.AllocationStrategyRefresh;
        }
        set refresh(value: AllocationStrategy.AllocationStrategyRefresh) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_refresh() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            type?: AllocationStrategy.Type;
            concurrency?: ReturnType<typeof AllocationStrategy.AllocationStrategyConcurrency.prototype.toObject>;
            refresh?: ReturnType<typeof AllocationStrategy.AllocationStrategyRefresh.prototype.toObject>;
        }): AllocationStrategy {
            const message = new AllocationStrategy({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.concurrency != null) {
                message.concurrency = AllocationStrategy.AllocationStrategyConcurrency.fromObject(data.concurrency);
            }
            if (data.refresh != null) {
                message.refresh = AllocationStrategy.AllocationStrategyRefresh.fromObject(data.refresh);
            }
            return message;
        }
        toObject() {
            const data: {
                type?: AllocationStrategy.Type;
                concurrency?: ReturnType<typeof AllocationStrategy.AllocationStrategyConcurrency.prototype.toObject>;
                refresh?: ReturnType<typeof AllocationStrategy.AllocationStrategyRefresh.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.concurrency != null) {
                data.concurrency = this.concurrency.toObject();
            }
            if (this.refresh != null) {
                data.refresh = this.refresh.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != AllocationStrategy.Type.Always)
                writer.writeEnum(1, this.type);
            if (this.has_concurrency)
                writer.writeMessage(2, this.concurrency, () => this.concurrency.serialize(writer));
            if (this.has_refresh)
                writer.writeMessage(3, this.refresh, () => this.refresh.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AllocationStrategy {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AllocationStrategy();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.concurrency, () => message.concurrency = AllocationStrategy.AllocationStrategyConcurrency.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.refresh, () => message.refresh = AllocationStrategy.AllocationStrategyRefresh.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AllocationStrategy {
            return AllocationStrategy.deserialize(bytes);
        }
    }
    export namespace AllocationStrategy {
        export enum Type {
            Always = 0,
            Random = 1,
            External = 2
        }
        export class AllocationStrategyConcurrency extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                value?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                value?: number;
            }): AllocationStrategyConcurrency {
                const message = new AllocationStrategyConcurrency({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: number;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.value != 0)
                    writer.writeUint32(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AllocationStrategyConcurrency {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AllocationStrategyConcurrency();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): AllocationStrategyConcurrency {
                return AllocationStrategyConcurrency.deserialize(bytes);
            }
        }
        export class AllocationStrategyRefresh extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                value?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                value?: number;
            }): AllocationStrategyRefresh {
                const message = new AllocationStrategyRefresh({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: number;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.value != 0)
                    writer.writeUint32(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AllocationStrategyRefresh {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AllocationStrategyRefresh();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): AllocationStrategyRefresh {
                return AllocationStrategyRefresh.deserialize(bytes);
            }
        }
    }
    export class SniffingConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            enabled?: boolean;
            destination_override?: string[];
            domains_excluded?: string[];
            metadata_only?: boolean;
            route_only?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("enabled" in data && data.enabled != undefined) {
                    this.enabled = data.enabled;
                }
                if ("destination_override" in data && data.destination_override != undefined) {
                    this.destination_override = data.destination_override;
                }
                if ("domains_excluded" in data && data.domains_excluded != undefined) {
                    this.domains_excluded = data.domains_excluded;
                }
                if ("metadata_only" in data && data.metadata_only != undefined) {
                    this.metadata_only = data.metadata_only;
                }
                if ("route_only" in data && data.route_only != undefined) {
                    this.route_only = data.route_only;
                }
            }
        }
        get enabled() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set enabled(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get destination_override() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set destination_override(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get domains_excluded() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set domains_excluded(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get metadata_only() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set metadata_only(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get route_only() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set route_only(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            enabled?: boolean;
            destination_override?: string[];
            domains_excluded?: string[];
            metadata_only?: boolean;
            route_only?: boolean;
        }): SniffingConfig {
            const message = new SniffingConfig({});
            if (data.enabled != null) {
                message.enabled = data.enabled;
            }
            if (data.destination_override != null) {
                message.destination_override = data.destination_override;
            }
            if (data.domains_excluded != null) {
                message.domains_excluded = data.domains_excluded;
            }
            if (data.metadata_only != null) {
                message.metadata_only = data.metadata_only;
            }
            if (data.route_only != null) {
                message.route_only = data.route_only;
            }
            return message;
        }
        toObject() {
            const data: {
                enabled?: boolean;
                destination_override?: string[];
                domains_excluded?: string[];
                metadata_only?: boolean;
                route_only?: boolean;
            } = {};
            if (this.enabled != null) {
                data.enabled = this.enabled;
            }
            if (this.destination_override != null) {
                data.destination_override = this.destination_override;
            }
            if (this.domains_excluded != null) {
                data.domains_excluded = this.domains_excluded;
            }
            if (this.metadata_only != null) {
                data.metadata_only = this.metadata_only;
            }
            if (this.route_only != null) {
                data.route_only = this.route_only;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.enabled != false)
                writer.writeBool(1, this.enabled);
            if (this.destination_override.length)
                writer.writeRepeatedString(2, this.destination_override);
            if (this.domains_excluded.length)
                writer.writeRepeatedString(3, this.domains_excluded);
            if (this.metadata_only != false)
                writer.writeBool(4, this.metadata_only);
            if (this.route_only != false)
                writer.writeBool(5, this.route_only);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SniffingConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SniffingConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.enabled = reader.readBool();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 4:
                        message.metadata_only = reader.readBool();
                        break;
                    case 5:
                        message.route_only = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SniffingConfig {
            return SniffingConfig.deserialize(bytes);
        }
    }
    export class ReceiverConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            port_list?: dependency_2.xray.common.net.PortList;
            listen?: dependency_1.xray.common.net.IPOrDomain;
            allocation_strategy?: AllocationStrategy;
            stream_settings?: dependency_3.xray.transport.internet.StreamConfig;
            receive_original_destination?: boolean;
            sniffing_settings?: SniffingConfig;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_list" in data && data.port_list != undefined) {
                    this.port_list = data.port_list;
                }
                if ("listen" in data && data.listen != undefined) {
                    this.listen = data.listen;
                }
                if ("allocation_strategy" in data && data.allocation_strategy != undefined) {
                    this.allocation_strategy = data.allocation_strategy;
                }
                if ("stream_settings" in data && data.stream_settings != undefined) {
                    this.stream_settings = data.stream_settings;
                }
                if ("receive_original_destination" in data && data.receive_original_destination != undefined) {
                    this.receive_original_destination = data.receive_original_destination;
                }
                if ("sniffing_settings" in data && data.sniffing_settings != undefined) {
                    this.sniffing_settings = data.sniffing_settings;
                }
            }
        }
        get port_list() {
            return pb_1.Message.getWrapperField(this, dependency_2.xray.common.net.PortList, 1) as dependency_2.xray.common.net.PortList;
        }
        set port_list(value: dependency_2.xray.common.net.PortList) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_port_list() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get listen() {
            return pb_1.Message.getWrapperField(this, dependency_1.xray.common.net.IPOrDomain, 2) as dependency_1.xray.common.net.IPOrDomain;
        }
        set listen(value: dependency_1.xray.common.net.IPOrDomain) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_listen() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get allocation_strategy() {
            return pb_1.Message.getWrapperField(this, AllocationStrategy, 3) as AllocationStrategy;
        }
        set allocation_strategy(value: AllocationStrategy) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_allocation_strategy() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get stream_settings() {
            return pb_1.Message.getWrapperField(this, dependency_3.xray.transport.internet.StreamConfig, 4) as dependency_3.xray.transport.internet.StreamConfig;
        }
        set stream_settings(value: dependency_3.xray.transport.internet.StreamConfig) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_stream_settings() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get receive_original_destination() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set receive_original_destination(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get sniffing_settings() {
            return pb_1.Message.getWrapperField(this, SniffingConfig, 7) as SniffingConfig;
        }
        set sniffing_settings(value: SniffingConfig) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_sniffing_settings() {
            return pb_1.Message.getField(this, 7) != null;
        }
        static fromObject(data: {
            port_list?: ReturnType<typeof dependency_2.xray.common.net.PortList.prototype.toObject>;
            listen?: ReturnType<typeof dependency_1.xray.common.net.IPOrDomain.prototype.toObject>;
            allocation_strategy?: ReturnType<typeof AllocationStrategy.prototype.toObject>;
            stream_settings?: ReturnType<typeof dependency_3.xray.transport.internet.StreamConfig.prototype.toObject>;
            receive_original_destination?: boolean;
            sniffing_settings?: ReturnType<typeof SniffingConfig.prototype.toObject>;
        }): ReceiverConfig {
            const message = new ReceiverConfig({});
            if (data.port_list != null) {
                message.port_list = dependency_2.xray.common.net.PortList.fromObject(data.port_list);
            }
            if (data.listen != null) {
                message.listen = dependency_1.xray.common.net.IPOrDomain.fromObject(data.listen);
            }
            if (data.allocation_strategy != null) {
                message.allocation_strategy = AllocationStrategy.fromObject(data.allocation_strategy);
            }
            if (data.stream_settings != null) {
                message.stream_settings = dependency_3.xray.transport.internet.StreamConfig.fromObject(data.stream_settings);
            }
            if (data.receive_original_destination != null) {
                message.receive_original_destination = data.receive_original_destination;
            }
            if (data.sniffing_settings != null) {
                message.sniffing_settings = SniffingConfig.fromObject(data.sniffing_settings);
            }
            return message;
        }
        toObject() {
            const data: {
                port_list?: ReturnType<typeof dependency_2.xray.common.net.PortList.prototype.toObject>;
                listen?: ReturnType<typeof dependency_1.xray.common.net.IPOrDomain.prototype.toObject>;
                allocation_strategy?: ReturnType<typeof AllocationStrategy.prototype.toObject>;
                stream_settings?: ReturnType<typeof dependency_3.xray.transport.internet.StreamConfig.prototype.toObject>;
                receive_original_destination?: boolean;
                sniffing_settings?: ReturnType<typeof SniffingConfig.prototype.toObject>;
            } = {};
            if (this.port_list != null) {
                data.port_list = this.port_list.toObject();
            }
            if (this.listen != null) {
                data.listen = this.listen.toObject();
            }
            if (this.allocation_strategy != null) {
                data.allocation_strategy = this.allocation_strategy.toObject();
            }
            if (this.stream_settings != null) {
                data.stream_settings = this.stream_settings.toObject();
            }
            if (this.receive_original_destination != null) {
                data.receive_original_destination = this.receive_original_destination;
            }
            if (this.sniffing_settings != null) {
                data.sniffing_settings = this.sniffing_settings.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_port_list)
                writer.writeMessage(1, this.port_list, () => this.port_list.serialize(writer));
            if (this.has_listen)
                writer.writeMessage(2, this.listen, () => this.listen.serialize(writer));
            if (this.has_allocation_strategy)
                writer.writeMessage(3, this.allocation_strategy, () => this.allocation_strategy.serialize(writer));
            if (this.has_stream_settings)
                writer.writeMessage(4, this.stream_settings, () => this.stream_settings.serialize(writer));
            if (this.receive_original_destination != false)
                writer.writeBool(5, this.receive_original_destination);
            if (this.has_sniffing_settings)
                writer.writeMessage(7, this.sniffing_settings, () => this.sniffing_settings.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiverConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReceiverConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.port_list, () => message.port_list = dependency_2.xray.common.net.PortList.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.listen, () => message.listen = dependency_1.xray.common.net.IPOrDomain.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.allocation_strategy, () => message.allocation_strategy = AllocationStrategy.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.stream_settings, () => message.stream_settings = dependency_3.xray.transport.internet.StreamConfig.deserialize(reader));
                        break;
                    case 5:
                        message.receive_original_destination = reader.readBool();
                        break;
                    case 7:
                        reader.readMessage(message.sniffing_settings, () => message.sniffing_settings = SniffingConfig.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReceiverConfig {
            return ReceiverConfig.deserialize(bytes);
        }
    }
    export class InboundHandlerConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tag?: string;
            receiver_settings?: dependency_4.xray.common.serial.TypedMessage;
            proxy_settings?: dependency_4.xray.common.serial.TypedMessage;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("receiver_settings" in data && data.receiver_settings != undefined) {
                    this.receiver_settings = data.receiver_settings;
                }
                if ("proxy_settings" in data && data.proxy_settings != undefined) {
                    this.proxy_settings = data.proxy_settings;
                }
            }
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get receiver_settings() {
            return pb_1.Message.getWrapperField(this, dependency_4.xray.common.serial.TypedMessage, 2) as dependency_4.xray.common.serial.TypedMessage;
        }
        set receiver_settings(value: dependency_4.xray.common.serial.TypedMessage) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_receiver_settings() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get proxy_settings() {
            return pb_1.Message.getWrapperField(this, dependency_4.xray.common.serial.TypedMessage, 3) as dependency_4.xray.common.serial.TypedMessage;
        }
        set proxy_settings(value: dependency_4.xray.common.serial.TypedMessage) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_proxy_settings() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            tag?: string;
            receiver_settings?: ReturnType<typeof dependency_4.xray.common.serial.TypedMessage.prototype.toObject>;
            proxy_settings?: ReturnType<typeof dependency_4.xray.common.serial.TypedMessage.prototype.toObject>;
        }): InboundHandlerConfig {
            const message = new InboundHandlerConfig({});
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.receiver_settings != null) {
                message.receiver_settings = dependency_4.xray.common.serial.TypedMessage.fromObject(data.receiver_settings);
            }
            if (data.proxy_settings != null) {
                message.proxy_settings = dependency_4.xray.common.serial.TypedMessage.fromObject(data.proxy_settings);
            }
            return message;
        }
        toObject() {
            const data: {
                tag?: string;
                receiver_settings?: ReturnType<typeof dependency_4.xray.common.serial.TypedMessage.prototype.toObject>;
                proxy_settings?: ReturnType<typeof dependency_4.xray.common.serial.TypedMessage.prototype.toObject>;
            } = {};
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.receiver_settings != null) {
                data.receiver_settings = this.receiver_settings.toObject();
            }
            if (this.proxy_settings != null) {
                data.proxy_settings = this.proxy_settings.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tag.length)
                writer.writeString(1, this.tag);
            if (this.has_receiver_settings)
                writer.writeMessage(2, this.receiver_settings, () => this.receiver_settings.serialize(writer));
            if (this.has_proxy_settings)
                writer.writeMessage(3, this.proxy_settings, () => this.proxy_settings.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InboundHandlerConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InboundHandlerConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tag = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.receiver_settings, () => message.receiver_settings = dependency_4.xray.common.serial.TypedMessage.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.proxy_settings, () => message.proxy_settings = dependency_4.xray.common.serial.TypedMessage.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InboundHandlerConfig {
            return InboundHandlerConfig.deserialize(bytes);
        }
    }
    export class OutboundConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): OutboundConfig {
            const message = new OutboundConfig({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutboundConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutboundConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OutboundConfig {
            return OutboundConfig.deserialize(bytes);
        }
    }
    export class SenderConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            via?: dependency_1.xray.common.net.IPOrDomain;
            stream_settings?: dependency_3.xray.transport.internet.StreamConfig;
            proxy_settings?: dependency_3.xray.transport.internet.ProxyConfig;
            multiplex_settings?: MultiplexingConfig;
            via_cidr?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("via" in data && data.via != undefined) {
                    this.via = data.via;
                }
                if ("stream_settings" in data && data.stream_settings != undefined) {
                    this.stream_settings = data.stream_settings;
                }
                if ("proxy_settings" in data && data.proxy_settings != undefined) {
                    this.proxy_settings = data.proxy_settings;
                }
                if ("multiplex_settings" in data && data.multiplex_settings != undefined) {
                    this.multiplex_settings = data.multiplex_settings;
                }
                if ("via_cidr" in data && data.via_cidr != undefined) {
                    this.via_cidr = data.via_cidr;
                }
            }
        }
        get via() {
            return pb_1.Message.getWrapperField(this, dependency_1.xray.common.net.IPOrDomain, 1) as dependency_1.xray.common.net.IPOrDomain;
        }
        set via(value: dependency_1.xray.common.net.IPOrDomain) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_via() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get stream_settings() {
            return pb_1.Message.getWrapperField(this, dependency_3.xray.transport.internet.StreamConfig, 2) as dependency_3.xray.transport.internet.StreamConfig;
        }
        set stream_settings(value: dependency_3.xray.transport.internet.StreamConfig) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_stream_settings() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get proxy_settings() {
            return pb_1.Message.getWrapperField(this, dependency_3.xray.transport.internet.ProxyConfig, 3) as dependency_3.xray.transport.internet.ProxyConfig;
        }
        set proxy_settings(value: dependency_3.xray.transport.internet.ProxyConfig) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_proxy_settings() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get multiplex_settings() {
            return pb_1.Message.getWrapperField(this, MultiplexingConfig, 4) as MultiplexingConfig;
        }
        set multiplex_settings(value: MultiplexingConfig) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_multiplex_settings() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get via_cidr() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set via_cidr(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            via?: ReturnType<typeof dependency_1.xray.common.net.IPOrDomain.prototype.toObject>;
            stream_settings?: ReturnType<typeof dependency_3.xray.transport.internet.StreamConfig.prototype.toObject>;
            proxy_settings?: ReturnType<typeof dependency_3.xray.transport.internet.ProxyConfig.prototype.toObject>;
            multiplex_settings?: ReturnType<typeof MultiplexingConfig.prototype.toObject>;
            via_cidr?: string;
        }): SenderConfig {
            const message = new SenderConfig({});
            if (data.via != null) {
                message.via = dependency_1.xray.common.net.IPOrDomain.fromObject(data.via);
            }
            if (data.stream_settings != null) {
                message.stream_settings = dependency_3.xray.transport.internet.StreamConfig.fromObject(data.stream_settings);
            }
            if (data.proxy_settings != null) {
                message.proxy_settings = dependency_3.xray.transport.internet.ProxyConfig.fromObject(data.proxy_settings);
            }
            if (data.multiplex_settings != null) {
                message.multiplex_settings = MultiplexingConfig.fromObject(data.multiplex_settings);
            }
            if (data.via_cidr != null) {
                message.via_cidr = data.via_cidr;
            }
            return message;
        }
        toObject() {
            const data: {
                via?: ReturnType<typeof dependency_1.xray.common.net.IPOrDomain.prototype.toObject>;
                stream_settings?: ReturnType<typeof dependency_3.xray.transport.internet.StreamConfig.prototype.toObject>;
                proxy_settings?: ReturnType<typeof dependency_3.xray.transport.internet.ProxyConfig.prototype.toObject>;
                multiplex_settings?: ReturnType<typeof MultiplexingConfig.prototype.toObject>;
                via_cidr?: string;
            } = {};
            if (this.via != null) {
                data.via = this.via.toObject();
            }
            if (this.stream_settings != null) {
                data.stream_settings = this.stream_settings.toObject();
            }
            if (this.proxy_settings != null) {
                data.proxy_settings = this.proxy_settings.toObject();
            }
            if (this.multiplex_settings != null) {
                data.multiplex_settings = this.multiplex_settings.toObject();
            }
            if (this.via_cidr != null) {
                data.via_cidr = this.via_cidr;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_via)
                writer.writeMessage(1, this.via, () => this.via.serialize(writer));
            if (this.has_stream_settings)
                writer.writeMessage(2, this.stream_settings, () => this.stream_settings.serialize(writer));
            if (this.has_proxy_settings)
                writer.writeMessage(3, this.proxy_settings, () => this.proxy_settings.serialize(writer));
            if (this.has_multiplex_settings)
                writer.writeMessage(4, this.multiplex_settings, () => this.multiplex_settings.serialize(writer));
            if (this.via_cidr.length)
                writer.writeString(5, this.via_cidr);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SenderConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SenderConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.via, () => message.via = dependency_1.xray.common.net.IPOrDomain.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.stream_settings, () => message.stream_settings = dependency_3.xray.transport.internet.StreamConfig.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.proxy_settings, () => message.proxy_settings = dependency_3.xray.transport.internet.ProxyConfig.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.multiplex_settings, () => message.multiplex_settings = MultiplexingConfig.deserialize(reader));
                        break;
                    case 5:
                        message.via_cidr = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SenderConfig {
            return SenderConfig.deserialize(bytes);
        }
    }
    export class MultiplexingConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            enabled?: boolean;
            concurrency?: number;
            xudpConcurrency?: number;
            xudpProxyUDP443?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("enabled" in data && data.enabled != undefined) {
                    this.enabled = data.enabled;
                }
                if ("concurrency" in data && data.concurrency != undefined) {
                    this.concurrency = data.concurrency;
                }
                if ("xudpConcurrency" in data && data.xudpConcurrency != undefined) {
                    this.xudpConcurrency = data.xudpConcurrency;
                }
                if ("xudpProxyUDP443" in data && data.xudpProxyUDP443 != undefined) {
                    this.xudpProxyUDP443 = data.xudpProxyUDP443;
                }
            }
        }
        get enabled() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set enabled(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get concurrency() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set concurrency(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get xudpConcurrency() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set xudpConcurrency(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get xudpProxyUDP443() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set xudpProxyUDP443(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            enabled?: boolean;
            concurrency?: number;
            xudpConcurrency?: number;
            xudpProxyUDP443?: string;
        }): MultiplexingConfig {
            const message = new MultiplexingConfig({});
            if (data.enabled != null) {
                message.enabled = data.enabled;
            }
            if (data.concurrency != null) {
                message.concurrency = data.concurrency;
            }
            if (data.xudpConcurrency != null) {
                message.xudpConcurrency = data.xudpConcurrency;
            }
            if (data.xudpProxyUDP443 != null) {
                message.xudpProxyUDP443 = data.xudpProxyUDP443;
            }
            return message;
        }
        toObject() {
            const data: {
                enabled?: boolean;
                concurrency?: number;
                xudpConcurrency?: number;
                xudpProxyUDP443?: string;
            } = {};
            if (this.enabled != null) {
                data.enabled = this.enabled;
            }
            if (this.concurrency != null) {
                data.concurrency = this.concurrency;
            }
            if (this.xudpConcurrency != null) {
                data.xudpConcurrency = this.xudpConcurrency;
            }
            if (this.xudpProxyUDP443 != null) {
                data.xudpProxyUDP443 = this.xudpProxyUDP443;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.enabled != false)
                writer.writeBool(1, this.enabled);
            if (this.concurrency != 0)
                writer.writeInt32(2, this.concurrency);
            if (this.xudpConcurrency != 0)
                writer.writeInt32(3, this.xudpConcurrency);
            if (this.xudpProxyUDP443.length)
                writer.writeString(4, this.xudpProxyUDP443);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MultiplexingConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MultiplexingConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.enabled = reader.readBool();
                        break;
                    case 2:
                        message.concurrency = reader.readInt32();
                        break;
                    case 3:
                        message.xudpConcurrency = reader.readInt32();
                        break;
                    case 4:
                        message.xudpProxyUDP443 = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MultiplexingConfig {
            return MultiplexingConfig.deserialize(bytes);
        }
    }
}
