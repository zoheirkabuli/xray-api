// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.3
//   protoc               v6.31.1
// source: app/proxyman/command/command.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { User } from "../../../common/protocol/user";
import { TypedMessage } from "../../../common/serial/typed_message";
import { InboundHandlerConfig, OutboundHandlerConfig } from "../../../core/config";

export const protobufPackage = "xray.app.proxyman.command";

export interface AddUserOperation {
  user: User | undefined;
}

export interface RemoveUserOperation {
  email: string;
}

export interface AddInboundRequest {
  inbound: InboundHandlerConfig | undefined;
}

export interface AddInboundResponse {
}

export interface RemoveInboundRequest {
  tag: string;
}

export interface RemoveInboundResponse {
}

export interface AlterInboundRequest {
  tag: string;
  operation: TypedMessage | undefined;
}

export interface AlterInboundResponse {
}

export interface ListInboundsRequest {
}

export interface ListInboundsResponse {
  inbounds: InboundHandlerConfig[];
}

export interface GetInboundUserRequest {
  tag: string;
  email: string;
}

export interface GetInboundUserResponse {
  users: User[];
}

export interface GetInboundUsersCountResponse {
  count: number;
}

export interface AddOutboundRequest {
  outbound: OutboundHandlerConfig | undefined;
}

export interface AddOutboundResponse {
}

export interface RemoveOutboundRequest {
  tag: string;
}

export interface RemoveOutboundResponse {
}

export interface AlterOutboundRequest {
  tag: string;
  operation: TypedMessage | undefined;
}

export interface AlterOutboundResponse {
}

export interface ListOutboundsRequest {
}

export interface ListOutboundsResponse {
  outbounds: OutboundHandlerConfig[];
}

export interface Config {
}

function createBaseAddUserOperation(): AddUserOperation {
  return { user: undefined };
}

export const AddUserOperation: MessageFns<AddUserOperation> = {
  encode(message: AddUserOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddUserOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUserOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddUserOperation {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: AddUserOperation): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUserOperation>, I>>(base?: I): AddUserOperation {
    return AddUserOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddUserOperation>, I>>(object: I): AddUserOperation {
    const message = createBaseAddUserOperation();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseRemoveUserOperation(): RemoveUserOperation {
  return { email: "" };
}

export const RemoveUserOperation: MessageFns<RemoveUserOperation> = {
  encode(message: RemoveUserOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveUserOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserOperation {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: RemoveUserOperation): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserOperation>, I>>(base?: I): RemoveUserOperation {
    return RemoveUserOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserOperation>, I>>(object: I): RemoveUserOperation {
    const message = createBaseRemoveUserOperation();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseAddInboundRequest(): AddInboundRequest {
  return { inbound: undefined };
}

export const AddInboundRequest: MessageFns<AddInboundRequest> = {
  encode(message: AddInboundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inbound !== undefined) {
      InboundHandlerConfig.encode(message.inbound, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddInboundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddInboundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inbound = InboundHandlerConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddInboundRequest {
    return { inbound: isSet(object.inbound) ? InboundHandlerConfig.fromJSON(object.inbound) : undefined };
  },

  toJSON(message: AddInboundRequest): unknown {
    const obj: any = {};
    if (message.inbound !== undefined) {
      obj.inbound = InboundHandlerConfig.toJSON(message.inbound);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddInboundRequest>, I>>(base?: I): AddInboundRequest {
    return AddInboundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddInboundRequest>, I>>(object: I): AddInboundRequest {
    const message = createBaseAddInboundRequest();
    message.inbound = (object.inbound !== undefined && object.inbound !== null)
      ? InboundHandlerConfig.fromPartial(object.inbound)
      : undefined;
    return message;
  },
};

function createBaseAddInboundResponse(): AddInboundResponse {
  return {};
}

export const AddInboundResponse: MessageFns<AddInboundResponse> = {
  encode(_: AddInboundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddInboundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddInboundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddInboundResponse {
    return {};
  },

  toJSON(_: AddInboundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddInboundResponse>, I>>(base?: I): AddInboundResponse {
    return AddInboundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddInboundResponse>, I>>(_: I): AddInboundResponse {
    const message = createBaseAddInboundResponse();
    return message;
  },
};

function createBaseRemoveInboundRequest(): RemoveInboundRequest {
  return { tag: "" };
}

export const RemoveInboundRequest: MessageFns<RemoveInboundRequest> = {
  encode(message: RemoveInboundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveInboundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveInboundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveInboundRequest {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: RemoveInboundRequest): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveInboundRequest>, I>>(base?: I): RemoveInboundRequest {
    return RemoveInboundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveInboundRequest>, I>>(object: I): RemoveInboundRequest {
    const message = createBaseRemoveInboundRequest();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseRemoveInboundResponse(): RemoveInboundResponse {
  return {};
}

export const RemoveInboundResponse: MessageFns<RemoveInboundResponse> = {
  encode(_: RemoveInboundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveInboundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveInboundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveInboundResponse {
    return {};
  },

  toJSON(_: RemoveInboundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveInboundResponse>, I>>(base?: I): RemoveInboundResponse {
    return RemoveInboundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveInboundResponse>, I>>(_: I): RemoveInboundResponse {
    const message = createBaseRemoveInboundResponse();
    return message;
  },
};

function createBaseAlterInboundRequest(): AlterInboundRequest {
  return { tag: "", operation: undefined };
}

export const AlterInboundRequest: MessageFns<AlterInboundRequest> = {
  encode(message: AlterInboundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.operation !== undefined) {
      TypedMessage.encode(message.operation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterInboundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterInboundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operation = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterInboundRequest {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      operation: isSet(object.operation) ? TypedMessage.fromJSON(object.operation) : undefined,
    };
  },

  toJSON(message: AlterInboundRequest): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.operation !== undefined) {
      obj.operation = TypedMessage.toJSON(message.operation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlterInboundRequest>, I>>(base?: I): AlterInboundRequest {
    return AlterInboundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlterInboundRequest>, I>>(object: I): AlterInboundRequest {
    const message = createBaseAlterInboundRequest();
    message.tag = object.tag ?? "";
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? TypedMessage.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseAlterInboundResponse(): AlterInboundResponse {
  return {};
}

export const AlterInboundResponse: MessageFns<AlterInboundResponse> = {
  encode(_: AlterInboundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterInboundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterInboundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AlterInboundResponse {
    return {};
  },

  toJSON(_: AlterInboundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AlterInboundResponse>, I>>(base?: I): AlterInboundResponse {
    return AlterInboundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlterInboundResponse>, I>>(_: I): AlterInboundResponse {
    const message = createBaseAlterInboundResponse();
    return message;
  },
};

function createBaseListInboundsRequest(): ListInboundsRequest {
  return {};
}

export const ListInboundsRequest: MessageFns<ListInboundsRequest> = {
  encode(_: ListInboundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInboundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInboundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListInboundsRequest {
    return {};
  },

  toJSON(_: ListInboundsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInboundsRequest>, I>>(base?: I): ListInboundsRequest {
    return ListInboundsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInboundsRequest>, I>>(_: I): ListInboundsRequest {
    const message = createBaseListInboundsRequest();
    return message;
  },
};

function createBaseListInboundsResponse(): ListInboundsResponse {
  return { inbounds: [] };
}

export const ListInboundsResponse: MessageFns<ListInboundsResponse> = {
  encode(message: ListInboundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inbounds) {
      InboundHandlerConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInboundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInboundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inbounds.push(InboundHandlerConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInboundsResponse {
    return {
      inbounds: globalThis.Array.isArray(object?.inbounds)
        ? object.inbounds.map((e: any) => InboundHandlerConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListInboundsResponse): unknown {
    const obj: any = {};
    if (message.inbounds?.length) {
      obj.inbounds = message.inbounds.map((e) => InboundHandlerConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInboundsResponse>, I>>(base?: I): ListInboundsResponse {
    return ListInboundsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInboundsResponse>, I>>(object: I): ListInboundsResponse {
    const message = createBaseListInboundsResponse();
    message.inbounds = object.inbounds?.map((e) => InboundHandlerConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetInboundUserRequest(): GetInboundUserRequest {
  return { tag: "", email: "" };
}

export const GetInboundUserRequest: MessageFns<GetInboundUserRequest> = {
  encode(message: GetInboundUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInboundUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInboundUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInboundUserRequest {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: GetInboundUserRequest): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInboundUserRequest>, I>>(base?: I): GetInboundUserRequest {
    return GetInboundUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInboundUserRequest>, I>>(object: I): GetInboundUserRequest {
    const message = createBaseGetInboundUserRequest();
    message.tag = object.tag ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGetInboundUserResponse(): GetInboundUserResponse {
  return { users: [] };
}

export const GetInboundUserResponse: MessageFns<GetInboundUserResponse> = {
  encode(message: GetInboundUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInboundUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInboundUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInboundUserResponse {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: GetInboundUserResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInboundUserResponse>, I>>(base?: I): GetInboundUserResponse {
    return GetInboundUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInboundUserResponse>, I>>(object: I): GetInboundUserResponse {
    const message = createBaseGetInboundUserResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetInboundUsersCountResponse(): GetInboundUsersCountResponse {
  return { count: 0 };
}

export const GetInboundUsersCountResponse: MessageFns<GetInboundUsersCountResponse> = {
  encode(message: GetInboundUsersCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInboundUsersCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInboundUsersCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInboundUsersCountResponse {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: GetInboundUsersCountResponse): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInboundUsersCountResponse>, I>>(base?: I): GetInboundUsersCountResponse {
    return GetInboundUsersCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInboundUsersCountResponse>, I>>(object: I): GetInboundUsersCountResponse {
    const message = createBaseGetInboundUsersCountResponse();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseAddOutboundRequest(): AddOutboundRequest {
  return { outbound: undefined };
}

export const AddOutboundRequest: MessageFns<AddOutboundRequest> = {
  encode(message: AddOutboundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outbound !== undefined) {
      OutboundHandlerConfig.encode(message.outbound, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddOutboundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOutboundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outbound = OutboundHandlerConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddOutboundRequest {
    return { outbound: isSet(object.outbound) ? OutboundHandlerConfig.fromJSON(object.outbound) : undefined };
  },

  toJSON(message: AddOutboundRequest): unknown {
    const obj: any = {};
    if (message.outbound !== undefined) {
      obj.outbound = OutboundHandlerConfig.toJSON(message.outbound);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOutboundRequest>, I>>(base?: I): AddOutboundRequest {
    return AddOutboundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddOutboundRequest>, I>>(object: I): AddOutboundRequest {
    const message = createBaseAddOutboundRequest();
    message.outbound = (object.outbound !== undefined && object.outbound !== null)
      ? OutboundHandlerConfig.fromPartial(object.outbound)
      : undefined;
    return message;
  },
};

function createBaseAddOutboundResponse(): AddOutboundResponse {
  return {};
}

export const AddOutboundResponse: MessageFns<AddOutboundResponse> = {
  encode(_: AddOutboundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddOutboundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOutboundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddOutboundResponse {
    return {};
  },

  toJSON(_: AddOutboundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOutboundResponse>, I>>(base?: I): AddOutboundResponse {
    return AddOutboundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddOutboundResponse>, I>>(_: I): AddOutboundResponse {
    const message = createBaseAddOutboundResponse();
    return message;
  },
};

function createBaseRemoveOutboundRequest(): RemoveOutboundRequest {
  return { tag: "" };
}

export const RemoveOutboundRequest: MessageFns<RemoveOutboundRequest> = {
  encode(message: RemoveOutboundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveOutboundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveOutboundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveOutboundRequest {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: RemoveOutboundRequest): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveOutboundRequest>, I>>(base?: I): RemoveOutboundRequest {
    return RemoveOutboundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveOutboundRequest>, I>>(object: I): RemoveOutboundRequest {
    const message = createBaseRemoveOutboundRequest();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseRemoveOutboundResponse(): RemoveOutboundResponse {
  return {};
}

export const RemoveOutboundResponse: MessageFns<RemoveOutboundResponse> = {
  encode(_: RemoveOutboundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveOutboundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveOutboundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveOutboundResponse {
    return {};
  },

  toJSON(_: RemoveOutboundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveOutboundResponse>, I>>(base?: I): RemoveOutboundResponse {
    return RemoveOutboundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveOutboundResponse>, I>>(_: I): RemoveOutboundResponse {
    const message = createBaseRemoveOutboundResponse();
    return message;
  },
};

function createBaseAlterOutboundRequest(): AlterOutboundRequest {
  return { tag: "", operation: undefined };
}

export const AlterOutboundRequest: MessageFns<AlterOutboundRequest> = {
  encode(message: AlterOutboundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.operation !== undefined) {
      TypedMessage.encode(message.operation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterOutboundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterOutboundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operation = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterOutboundRequest {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      operation: isSet(object.operation) ? TypedMessage.fromJSON(object.operation) : undefined,
    };
  },

  toJSON(message: AlterOutboundRequest): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.operation !== undefined) {
      obj.operation = TypedMessage.toJSON(message.operation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlterOutboundRequest>, I>>(base?: I): AlterOutboundRequest {
    return AlterOutboundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlterOutboundRequest>, I>>(object: I): AlterOutboundRequest {
    const message = createBaseAlterOutboundRequest();
    message.tag = object.tag ?? "";
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? TypedMessage.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseAlterOutboundResponse(): AlterOutboundResponse {
  return {};
}

export const AlterOutboundResponse: MessageFns<AlterOutboundResponse> = {
  encode(_: AlterOutboundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlterOutboundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterOutboundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AlterOutboundResponse {
    return {};
  },

  toJSON(_: AlterOutboundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AlterOutboundResponse>, I>>(base?: I): AlterOutboundResponse {
    return AlterOutboundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlterOutboundResponse>, I>>(_: I): AlterOutboundResponse {
    const message = createBaseAlterOutboundResponse();
    return message;
  },
};

function createBaseListOutboundsRequest(): ListOutboundsRequest {
  return {};
}

export const ListOutboundsRequest: MessageFns<ListOutboundsRequest> = {
  encode(_: ListOutboundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOutboundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOutboundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListOutboundsRequest {
    return {};
  },

  toJSON(_: ListOutboundsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOutboundsRequest>, I>>(base?: I): ListOutboundsRequest {
    return ListOutboundsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOutboundsRequest>, I>>(_: I): ListOutboundsRequest {
    const message = createBaseListOutboundsRequest();
    return message;
  },
};

function createBaseListOutboundsResponse(): ListOutboundsResponse {
  return { outbounds: [] };
}

export const ListOutboundsResponse: MessageFns<ListOutboundsResponse> = {
  encode(message: ListOutboundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.outbounds) {
      OutboundHandlerConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOutboundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOutboundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outbounds.push(OutboundHandlerConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOutboundsResponse {
    return {
      outbounds: globalThis.Array.isArray(object?.outbounds)
        ? object.outbounds.map((e: any) => OutboundHandlerConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListOutboundsResponse): unknown {
    const obj: any = {};
    if (message.outbounds?.length) {
      obj.outbounds = message.outbounds.map((e) => OutboundHandlerConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOutboundsResponse>, I>>(base?: I): ListOutboundsResponse {
    return ListOutboundsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOutboundsResponse>, I>>(object: I): ListOutboundsResponse {
    const message = createBaseListOutboundsResponse();
    message.outbounds = object.outbounds?.map((e) => OutboundHandlerConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConfig(): Config {
  return {};
}

export const Config: MessageFns<Config> = {
  encode(_: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Config {
    return {};
  },

  toJSON(_: Config): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(_: I): Config {
    const message = createBaseConfig();
    return message;
  },
};

export interface HandlerService {
  AddInbound(request: AddInboundRequest): Promise<AddInboundResponse>;
  RemoveInbound(request: RemoveInboundRequest): Promise<RemoveInboundResponse>;
  AlterInbound(request: AlterInboundRequest): Promise<AlterInboundResponse>;
  ListInbounds(request: ListInboundsRequest): Promise<ListInboundsResponse>;
  GetInboundUsers(request: GetInboundUserRequest): Promise<GetInboundUserResponse>;
  GetInboundUsersCount(request: GetInboundUserRequest): Promise<GetInboundUsersCountResponse>;
  AddOutbound(request: AddOutboundRequest): Promise<AddOutboundResponse>;
  RemoveOutbound(request: RemoveOutboundRequest): Promise<RemoveOutboundResponse>;
  AlterOutbound(request: AlterOutboundRequest): Promise<AlterOutboundResponse>;
  ListOutbounds(request: ListOutboundsRequest): Promise<ListOutboundsResponse>;
}

export const HandlerServiceServiceName = "xray.app.proxyman.command.HandlerService";
export class HandlerServiceClientImpl implements HandlerService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || HandlerServiceServiceName;
    this.rpc = rpc;
    this.AddInbound = this.AddInbound.bind(this);
    this.RemoveInbound = this.RemoveInbound.bind(this);
    this.AlterInbound = this.AlterInbound.bind(this);
    this.ListInbounds = this.ListInbounds.bind(this);
    this.GetInboundUsers = this.GetInboundUsers.bind(this);
    this.GetInboundUsersCount = this.GetInboundUsersCount.bind(this);
    this.AddOutbound = this.AddOutbound.bind(this);
    this.RemoveOutbound = this.RemoveOutbound.bind(this);
    this.AlterOutbound = this.AlterOutbound.bind(this);
    this.ListOutbounds = this.ListOutbounds.bind(this);
  }
  AddInbound(request: AddInboundRequest): Promise<AddInboundResponse> {
    const data = AddInboundRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddInbound", data);
    return promise.then((data) => AddInboundResponse.decode(new BinaryReader(data)));
  }

  RemoveInbound(request: RemoveInboundRequest): Promise<RemoveInboundResponse> {
    const data = RemoveInboundRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveInbound", data);
    return promise.then((data) => RemoveInboundResponse.decode(new BinaryReader(data)));
  }

  AlterInbound(request: AlterInboundRequest): Promise<AlterInboundResponse> {
    const data = AlterInboundRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AlterInbound", data);
    return promise.then((data) => AlterInboundResponse.decode(new BinaryReader(data)));
  }

  ListInbounds(request: ListInboundsRequest): Promise<ListInboundsResponse> {
    const data = ListInboundsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListInbounds", data);
    return promise.then((data) => ListInboundsResponse.decode(new BinaryReader(data)));
  }

  GetInboundUsers(request: GetInboundUserRequest): Promise<GetInboundUserResponse> {
    const data = GetInboundUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInboundUsers", data);
    return promise.then((data) => GetInboundUserResponse.decode(new BinaryReader(data)));
  }

  GetInboundUsersCount(request: GetInboundUserRequest): Promise<GetInboundUsersCountResponse> {
    const data = GetInboundUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInboundUsersCount", data);
    return promise.then((data) => GetInboundUsersCountResponse.decode(new BinaryReader(data)));
  }

  AddOutbound(request: AddOutboundRequest): Promise<AddOutboundResponse> {
    const data = AddOutboundRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddOutbound", data);
    return promise.then((data) => AddOutboundResponse.decode(new BinaryReader(data)));
  }

  RemoveOutbound(request: RemoveOutboundRequest): Promise<RemoveOutboundResponse> {
    const data = RemoveOutboundRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveOutbound", data);
    return promise.then((data) => RemoveOutboundResponse.decode(new BinaryReader(data)));
  }

  AlterOutbound(request: AlterOutboundRequest): Promise<AlterOutboundResponse> {
    const data = AlterOutboundRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AlterOutbound", data);
    return promise.then((data) => AlterOutboundResponse.decode(new BinaryReader(data)));
  }

  ListOutbounds(request: ListOutboundsRequest): Promise<ListOutboundsResponse> {
    const data = ListOutboundsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListOutbounds", data);
    return promise.then((data) => ListOutboundsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
