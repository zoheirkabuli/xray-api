// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.3
//   protoc               v6.31.1
// source: app/observatory/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "xray.core.app.observatory";

export interface ObservationResult {
  status: OutboundStatus[];
}

export interface HealthPingMeasurementResult {
  all: number;
  fail: number;
  deviation: number;
  average: number;
  max: number;
  min: number;
}

export interface OutboundStatus {
  /**
   * @Document Whether this outbound is usable
   * @Restriction ReadOnlyForUser
   */
  alive: boolean;
  /**
   * @Document The time for probe request to finish.
   * @Type time.ms
   * @Restriction ReadOnlyForUser
   */
  delay: number;
  /**
   * @Document The last error caused this outbound failed to relay probe request
   * @Restriction NotMachineReadable
   */
  lastErrorReason: string;
  /**
   * @Document The outbound tag for this Server
   * @Type id.outboundTag
   */
  outboundTag: string;
  /**
   * @Document The time this outbound is known to be alive
   * @Type id.outboundTag
   */
  lastSeenTime: number;
  /**
   * @Document The time this outbound is tried
   * @Type id.outboundTag
   */
  lastTryTime: number;
  healthPing: HealthPingMeasurementResult | undefined;
}

export interface ProbeResult {
  /**
   * @Document Whether this outbound is usable
   * @Restriction ReadOnlyForUser
   */
  alive: boolean;
  /**
   * @Document The time for probe request to finish.
   * @Type time.ms
   * @Restriction ReadOnlyForUser
   */
  delay: number;
  /**
   * @Document The error caused this outbound failed to relay probe request
   * @Restriction NotMachineReadable
   */
  lastErrorReason: string;
}

export interface Intensity {
  /**
   * @Document The time interval for a probe request in ms.
   * @Type time.ms
   */
  probeInterval: number;
}

export interface Config {
  /** @Document The selectors for outbound under observation */
  subjectSelector: string[];
  probeUrl: string;
  probeInterval: number;
  enableConcurrency: boolean;
}

function createBaseObservationResult(): ObservationResult {
  return { status: [] };
}

export const ObservationResult: MessageFns<ObservationResult> = {
  encode(message: ObservationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.status) {
      OutboundStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObservationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObservationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status.push(OutboundStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObservationResult {
    return {
      status: globalThis.Array.isArray(object?.status) ? object.status.map((e: any) => OutboundStatus.fromJSON(e)) : [],
    };
  },

  toJSON(message: ObservationResult): unknown {
    const obj: any = {};
    if (message.status?.length) {
      obj.status = message.status.map((e) => OutboundStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ObservationResult>, I>>(base?: I): ObservationResult {
    return ObservationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ObservationResult>, I>>(object: I): ObservationResult {
    const message = createBaseObservationResult();
    message.status = object.status?.map((e) => OutboundStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHealthPingMeasurementResult(): HealthPingMeasurementResult {
  return { all: 0, fail: 0, deviation: 0, average: 0, max: 0, min: 0 };
}

export const HealthPingMeasurementResult: MessageFns<HealthPingMeasurementResult> = {
  encode(message: HealthPingMeasurementResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.all !== 0) {
      writer.uint32(8).int64(message.all);
    }
    if (message.fail !== 0) {
      writer.uint32(16).int64(message.fail);
    }
    if (message.deviation !== 0) {
      writer.uint32(24).int64(message.deviation);
    }
    if (message.average !== 0) {
      writer.uint32(32).int64(message.average);
    }
    if (message.max !== 0) {
      writer.uint32(40).int64(message.max);
    }
    if (message.min !== 0) {
      writer.uint32(48).int64(message.min);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthPingMeasurementResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthPingMeasurementResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.all = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fail = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deviation = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.average = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.max = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.min = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthPingMeasurementResult {
    return {
      all: isSet(object.all) ? globalThis.Number(object.all) : 0,
      fail: isSet(object.fail) ? globalThis.Number(object.fail) : 0,
      deviation: isSet(object.deviation) ? globalThis.Number(object.deviation) : 0,
      average: isSet(object.average) ? globalThis.Number(object.average) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
    };
  },

  toJSON(message: HealthPingMeasurementResult): unknown {
    const obj: any = {};
    if (message.all !== 0) {
      obj.all = Math.round(message.all);
    }
    if (message.fail !== 0) {
      obj.fail = Math.round(message.fail);
    }
    if (message.deviation !== 0) {
      obj.deviation = Math.round(message.deviation);
    }
    if (message.average !== 0) {
      obj.average = Math.round(message.average);
    }
    if (message.max !== 0) {
      obj.max = Math.round(message.max);
    }
    if (message.min !== 0) {
      obj.min = Math.round(message.min);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthPingMeasurementResult>, I>>(base?: I): HealthPingMeasurementResult {
    return HealthPingMeasurementResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthPingMeasurementResult>, I>>(object: I): HealthPingMeasurementResult {
    const message = createBaseHealthPingMeasurementResult();
    message.all = object.all ?? 0;
    message.fail = object.fail ?? 0;
    message.deviation = object.deviation ?? 0;
    message.average = object.average ?? 0;
    message.max = object.max ?? 0;
    message.min = object.min ?? 0;
    return message;
  },
};

function createBaseOutboundStatus(): OutboundStatus {
  return {
    alive: false,
    delay: 0,
    lastErrorReason: "",
    outboundTag: "",
    lastSeenTime: 0,
    lastTryTime: 0,
    healthPing: undefined,
  };
}

export const OutboundStatus: MessageFns<OutboundStatus> = {
  encode(message: OutboundStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alive !== false) {
      writer.uint32(8).bool(message.alive);
    }
    if (message.delay !== 0) {
      writer.uint32(16).int64(message.delay);
    }
    if (message.lastErrorReason !== "") {
      writer.uint32(26).string(message.lastErrorReason);
    }
    if (message.outboundTag !== "") {
      writer.uint32(34).string(message.outboundTag);
    }
    if (message.lastSeenTime !== 0) {
      writer.uint32(40).int64(message.lastSeenTime);
    }
    if (message.lastTryTime !== 0) {
      writer.uint32(48).int64(message.lastTryTime);
    }
    if (message.healthPing !== undefined) {
      HealthPingMeasurementResult.encode(message.healthPing, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.delay = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastErrorReason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outboundTag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastSeenTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastTryTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.healthPing = HealthPingMeasurementResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundStatus {
    return {
      alive: isSet(object.alive) ? globalThis.Boolean(object.alive) : false,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      lastErrorReason: isSet(object.lastErrorReason) ? globalThis.String(object.lastErrorReason) : "",
      outboundTag: isSet(object.outboundTag) ? globalThis.String(object.outboundTag) : "",
      lastSeenTime: isSet(object.lastSeenTime) ? globalThis.Number(object.lastSeenTime) : 0,
      lastTryTime: isSet(object.lastTryTime) ? globalThis.Number(object.lastTryTime) : 0,
      healthPing: isSet(object.healthPing) ? HealthPingMeasurementResult.fromJSON(object.healthPing) : undefined,
    };
  },

  toJSON(message: OutboundStatus): unknown {
    const obj: any = {};
    if (message.alive !== false) {
      obj.alive = message.alive;
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.lastErrorReason !== "") {
      obj.lastErrorReason = message.lastErrorReason;
    }
    if (message.outboundTag !== "") {
      obj.outboundTag = message.outboundTag;
    }
    if (message.lastSeenTime !== 0) {
      obj.lastSeenTime = Math.round(message.lastSeenTime);
    }
    if (message.lastTryTime !== 0) {
      obj.lastTryTime = Math.round(message.lastTryTime);
    }
    if (message.healthPing !== undefined) {
      obj.healthPing = HealthPingMeasurementResult.toJSON(message.healthPing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutboundStatus>, I>>(base?: I): OutboundStatus {
    return OutboundStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutboundStatus>, I>>(object: I): OutboundStatus {
    const message = createBaseOutboundStatus();
    message.alive = object.alive ?? false;
    message.delay = object.delay ?? 0;
    message.lastErrorReason = object.lastErrorReason ?? "";
    message.outboundTag = object.outboundTag ?? "";
    message.lastSeenTime = object.lastSeenTime ?? 0;
    message.lastTryTime = object.lastTryTime ?? 0;
    message.healthPing = (object.healthPing !== undefined && object.healthPing !== null)
      ? HealthPingMeasurementResult.fromPartial(object.healthPing)
      : undefined;
    return message;
  },
};

function createBaseProbeResult(): ProbeResult {
  return { alive: false, delay: 0, lastErrorReason: "" };
}

export const ProbeResult: MessageFns<ProbeResult> = {
  encode(message: ProbeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alive !== false) {
      writer.uint32(8).bool(message.alive);
    }
    if (message.delay !== 0) {
      writer.uint32(16).int64(message.delay);
    }
    if (message.lastErrorReason !== "") {
      writer.uint32(26).string(message.lastErrorReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProbeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProbeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.delay = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastErrorReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProbeResult {
    return {
      alive: isSet(object.alive) ? globalThis.Boolean(object.alive) : false,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      lastErrorReason: isSet(object.lastErrorReason) ? globalThis.String(object.lastErrorReason) : "",
    };
  },

  toJSON(message: ProbeResult): unknown {
    const obj: any = {};
    if (message.alive !== false) {
      obj.alive = message.alive;
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.lastErrorReason !== "") {
      obj.lastErrorReason = message.lastErrorReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProbeResult>, I>>(base?: I): ProbeResult {
    return ProbeResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProbeResult>, I>>(object: I): ProbeResult {
    const message = createBaseProbeResult();
    message.alive = object.alive ?? false;
    message.delay = object.delay ?? 0;
    message.lastErrorReason = object.lastErrorReason ?? "";
    return message;
  },
};

function createBaseIntensity(): Intensity {
  return { probeInterval: 0 };
}

export const Intensity: MessageFns<Intensity> = {
  encode(message: Intensity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.probeInterval !== 0) {
      writer.uint32(8).uint32(message.probeInterval);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intensity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntensity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.probeInterval = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intensity {
    return { probeInterval: isSet(object.probeInterval) ? globalThis.Number(object.probeInterval) : 0 };
  },

  toJSON(message: Intensity): unknown {
    const obj: any = {};
    if (message.probeInterval !== 0) {
      obj.probeInterval = Math.round(message.probeInterval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Intensity>, I>>(base?: I): Intensity {
    return Intensity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Intensity>, I>>(object: I): Intensity {
    const message = createBaseIntensity();
    message.probeInterval = object.probeInterval ?? 0;
    return message;
  },
};

function createBaseConfig(): Config {
  return { subjectSelector: [], probeUrl: "", probeInterval: 0, enableConcurrency: false };
}

export const Config: MessageFns<Config> = {
  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subjectSelector) {
      writer.uint32(18).string(v!);
    }
    if (message.probeUrl !== "") {
      writer.uint32(26).string(message.probeUrl);
    }
    if (message.probeInterval !== 0) {
      writer.uint32(32).int64(message.probeInterval);
    }
    if (message.enableConcurrency !== false) {
      writer.uint32(40).bool(message.enableConcurrency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectSelector.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.probeUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.probeInterval = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enableConcurrency = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      subjectSelector: globalThis.Array.isArray(object?.subjectSelector)
        ? object.subjectSelector.map((e: any) => globalThis.String(e))
        : [],
      probeUrl: isSet(object.probeUrl) ? globalThis.String(object.probeUrl) : "",
      probeInterval: isSet(object.probeInterval) ? globalThis.Number(object.probeInterval) : 0,
      enableConcurrency: isSet(object.enableConcurrency) ? globalThis.Boolean(object.enableConcurrency) : false,
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.subjectSelector?.length) {
      obj.subjectSelector = message.subjectSelector;
    }
    if (message.probeUrl !== "") {
      obj.probeUrl = message.probeUrl;
    }
    if (message.probeInterval !== 0) {
      obj.probeInterval = Math.round(message.probeInterval);
    }
    if (message.enableConcurrency !== false) {
      obj.enableConcurrency = message.enableConcurrency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.subjectSelector = object.subjectSelector?.map((e) => e) || [];
    message.probeUrl = object.probeUrl ?? "";
    message.probeInterval = object.probeInterval ?? 0;
    message.enableConcurrency = object.enableConcurrency ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
