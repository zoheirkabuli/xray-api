/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: app/dns/config.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../common/net/destination";
import * as dependency_2 from "./../router/config";
import * as pb_1 from "google-protobuf";
export namespace xray.app.dns {
    export enum DomainMatchingType {
        Full = 0,
        Subdomain = 1,
        Keyword = 2,
        Regex = 3
    }
    export enum QueryStrategy {
        USE_IP = 0,
        USE_IP4 = 1,
        USE_IP6 = 2
    }
    export class NameServer extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: dependency_1.xray.common.net.Endpoint;
            client_ip?: Uint8Array;
            skipFallback?: boolean;
            prioritized_domain?: NameServer.PriorityDomain[];
            geoip?: dependency_2.xray.app.router.GeoIP[];
            original_rules?: NameServer.OriginalRule[];
            query_strategy?: QueryStrategy;
            allowUnexpectedIPs?: boolean;
            tag?: string;
            timeoutMs?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("client_ip" in data && data.client_ip != undefined) {
                    this.client_ip = data.client_ip;
                }
                if ("skipFallback" in data && data.skipFallback != undefined) {
                    this.skipFallback = data.skipFallback;
                }
                if ("prioritized_domain" in data && data.prioritized_domain != undefined) {
                    this.prioritized_domain = data.prioritized_domain;
                }
                if ("geoip" in data && data.geoip != undefined) {
                    this.geoip = data.geoip;
                }
                if ("original_rules" in data && data.original_rules != undefined) {
                    this.original_rules = data.original_rules;
                }
                if ("query_strategy" in data && data.query_strategy != undefined) {
                    this.query_strategy = data.query_strategy;
                }
                if ("allowUnexpectedIPs" in data && data.allowUnexpectedIPs != undefined) {
                    this.allowUnexpectedIPs = data.allowUnexpectedIPs;
                }
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("timeoutMs" in data && data.timeoutMs != undefined) {
                    this.timeoutMs = data.timeoutMs;
                }
            }
        }
        get address() {
            return pb_1.Message.getWrapperField(this, dependency_1.xray.common.net.Endpoint, 1) as dependency_1.xray.common.net.Endpoint;
        }
        set address(value: dependency_1.xray.common.net.Endpoint) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_address() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get client_ip() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set client_ip(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get skipFallback() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set skipFallback(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get prioritized_domain() {
            return pb_1.Message.getRepeatedWrapperField(this, NameServer.PriorityDomain, 2) as NameServer.PriorityDomain[];
        }
        set prioritized_domain(value: NameServer.PriorityDomain[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get geoip() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.xray.app.router.GeoIP, 3) as dependency_2.xray.app.router.GeoIP[];
        }
        set geoip(value: dependency_2.xray.app.router.GeoIP[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get original_rules() {
            return pb_1.Message.getRepeatedWrapperField(this, NameServer.OriginalRule, 4) as NameServer.OriginalRule[];
        }
        set original_rules(value: NameServer.OriginalRule[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get query_strategy() {
            return pb_1.Message.getFieldWithDefault(this, 7, QueryStrategy.USE_IP) as QueryStrategy;
        }
        set query_strategy(value: QueryStrategy) {
            pb_1.Message.setField(this, 7, value);
        }
        get allowUnexpectedIPs() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set allowUnexpectedIPs(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get timeoutMs() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set timeoutMs(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            address?: ReturnType<typeof dependency_1.xray.common.net.Endpoint.prototype.toObject>;
            client_ip?: Uint8Array;
            skipFallback?: boolean;
            prioritized_domain?: ReturnType<typeof NameServer.PriorityDomain.prototype.toObject>[];
            geoip?: ReturnType<typeof dependency_2.xray.app.router.GeoIP.prototype.toObject>[];
            original_rules?: ReturnType<typeof NameServer.OriginalRule.prototype.toObject>[];
            query_strategy?: QueryStrategy;
            allowUnexpectedIPs?: boolean;
            tag?: string;
            timeoutMs?: number;
        }): NameServer {
            const message = new NameServer({});
            if (data.address != null) {
                message.address = dependency_1.xray.common.net.Endpoint.fromObject(data.address);
            }
            if (data.client_ip != null) {
                message.client_ip = data.client_ip;
            }
            if (data.skipFallback != null) {
                message.skipFallback = data.skipFallback;
            }
            if (data.prioritized_domain != null) {
                message.prioritized_domain = data.prioritized_domain.map(item => NameServer.PriorityDomain.fromObject(item));
            }
            if (data.geoip != null) {
                message.geoip = data.geoip.map(item => dependency_2.xray.app.router.GeoIP.fromObject(item));
            }
            if (data.original_rules != null) {
                message.original_rules = data.original_rules.map(item => NameServer.OriginalRule.fromObject(item));
            }
            if (data.query_strategy != null) {
                message.query_strategy = data.query_strategy;
            }
            if (data.allowUnexpectedIPs != null) {
                message.allowUnexpectedIPs = data.allowUnexpectedIPs;
            }
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.timeoutMs != null) {
                message.timeoutMs = data.timeoutMs;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: ReturnType<typeof dependency_1.xray.common.net.Endpoint.prototype.toObject>;
                client_ip?: Uint8Array;
                skipFallback?: boolean;
                prioritized_domain?: ReturnType<typeof NameServer.PriorityDomain.prototype.toObject>[];
                geoip?: ReturnType<typeof dependency_2.xray.app.router.GeoIP.prototype.toObject>[];
                original_rules?: ReturnType<typeof NameServer.OriginalRule.prototype.toObject>[];
                query_strategy?: QueryStrategy;
                allowUnexpectedIPs?: boolean;
                tag?: string;
                timeoutMs?: number;
            } = {};
            if (this.address != null) {
                data.address = this.address.toObject();
            }
            if (this.client_ip != null) {
                data.client_ip = this.client_ip;
            }
            if (this.skipFallback != null) {
                data.skipFallback = this.skipFallback;
            }
            if (this.prioritized_domain != null) {
                data.prioritized_domain = this.prioritized_domain.map((item: NameServer.PriorityDomain) => item.toObject());
            }
            if (this.geoip != null) {
                data.geoip = this.geoip.map((item: dependency_2.xray.app.router.GeoIP) => item.toObject());
            }
            if (this.original_rules != null) {
                data.original_rules = this.original_rules.map((item: NameServer.OriginalRule) => item.toObject());
            }
            if (this.query_strategy != null) {
                data.query_strategy = this.query_strategy;
            }
            if (this.allowUnexpectedIPs != null) {
                data.allowUnexpectedIPs = this.allowUnexpectedIPs;
            }
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.timeoutMs != null) {
                data.timeoutMs = this.timeoutMs;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_address)
                writer.writeMessage(1, this.address, () => this.address.serialize(writer));
            if (this.client_ip.length)
                writer.writeBytes(5, this.client_ip);
            if (this.skipFallback != false)
                writer.writeBool(6, this.skipFallback);
            if (this.prioritized_domain.length)
                writer.writeRepeatedMessage(2, this.prioritized_domain, (item: NameServer.PriorityDomain) => item.serialize(writer));
            if (this.geoip.length)
                writer.writeRepeatedMessage(3, this.geoip, (item: dependency_2.xray.app.router.GeoIP) => item.serialize(writer));
            if (this.original_rules.length)
                writer.writeRepeatedMessage(4, this.original_rules, (item: NameServer.OriginalRule) => item.serialize(writer));
            if (this.query_strategy != QueryStrategy.USE_IP)
                writer.writeEnum(7, this.query_strategy);
            if (this.allowUnexpectedIPs != false)
                writer.writeBool(8, this.allowUnexpectedIPs);
            if (this.tag.length)
                writer.writeString(9, this.tag);
            if (this.timeoutMs != 0)
                writer.writeUint64(10, this.timeoutMs);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NameServer {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NameServer();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.address, () => message.address = dependency_1.xray.common.net.Endpoint.deserialize(reader));
                        break;
                    case 5:
                        message.client_ip = reader.readBytes();
                        break;
                    case 6:
                        message.skipFallback = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.prioritized_domain, () => pb_1.Message.addToRepeatedWrapperField(message, 2, NameServer.PriorityDomain.deserialize(reader), NameServer.PriorityDomain));
                        break;
                    case 3:
                        reader.readMessage(message.geoip, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_2.xray.app.router.GeoIP.deserialize(reader), dependency_2.xray.app.router.GeoIP));
                        break;
                    case 4:
                        reader.readMessage(message.original_rules, () => pb_1.Message.addToRepeatedWrapperField(message, 4, NameServer.OriginalRule.deserialize(reader), NameServer.OriginalRule));
                        break;
                    case 7:
                        message.query_strategy = reader.readEnum();
                        break;
                    case 8:
                        message.allowUnexpectedIPs = reader.readBool();
                        break;
                    case 9:
                        message.tag = reader.readString();
                        break;
                    case 10:
                        message.timeoutMs = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NameServer {
            return NameServer.deserialize(bytes);
        }
    }
    export namespace NameServer {
        export class PriorityDomain extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: DomainMatchingType;
                domain?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("domain" in data && data.domain != undefined) {
                        this.domain = data.domain;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, DomainMatchingType.Full) as DomainMatchingType;
            }
            set type(value: DomainMatchingType) {
                pb_1.Message.setField(this, 1, value);
            }
            get domain() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set domain(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                type?: DomainMatchingType;
                domain?: string;
            }): PriorityDomain {
                const message = new PriorityDomain({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.domain != null) {
                    message.domain = data.domain;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: DomainMatchingType;
                    domain?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.domain != null) {
                    data.domain = this.domain;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != DomainMatchingType.Full)
                    writer.writeEnum(1, this.type);
                if (this.domain.length)
                    writer.writeString(2, this.domain);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PriorityDomain {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PriorityDomain();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.domain = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): PriorityDomain {
                return PriorityDomain.deserialize(bytes);
            }
        }
        export class OriginalRule extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                rule?: string;
                size?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("rule" in data && data.rule != undefined) {
                        this.rule = data.rule;
                    }
                    if ("size" in data && data.size != undefined) {
                        this.size = data.size;
                    }
                }
            }
            get rule() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set rule(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get size() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set size(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                rule?: string;
                size?: number;
            }): OriginalRule {
                const message = new OriginalRule({});
                if (data.rule != null) {
                    message.rule = data.rule;
                }
                if (data.size != null) {
                    message.size = data.size;
                }
                return message;
            }
            toObject() {
                const data: {
                    rule?: string;
                    size?: number;
                } = {};
                if (this.rule != null) {
                    data.rule = this.rule;
                }
                if (this.size != null) {
                    data.size = this.size;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.rule.length)
                    writer.writeString(1, this.rule);
                if (this.size != 0)
                    writer.writeUint32(2, this.size);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OriginalRule {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OriginalRule();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.rule = reader.readString();
                            break;
                        case 2:
                            message.size = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): OriginalRule {
                return OriginalRule.deserialize(bytes);
            }
        }
    }
    export class Config extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name_server?: NameServer[];
            client_ip?: Uint8Array;
            static_hosts?: Config.HostMapping[];
            tag?: string;
            disableCache?: boolean;
            query_strategy?: QueryStrategy;
            disableFallback?: boolean;
            disableFallbackIfMatch?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name_server" in data && data.name_server != undefined) {
                    this.name_server = data.name_server;
                }
                if ("client_ip" in data && data.client_ip != undefined) {
                    this.client_ip = data.client_ip;
                }
                if ("static_hosts" in data && data.static_hosts != undefined) {
                    this.static_hosts = data.static_hosts;
                }
                if ("tag" in data && data.tag != undefined) {
                    this.tag = data.tag;
                }
                if ("disableCache" in data && data.disableCache != undefined) {
                    this.disableCache = data.disableCache;
                }
                if ("query_strategy" in data && data.query_strategy != undefined) {
                    this.query_strategy = data.query_strategy;
                }
                if ("disableFallback" in data && data.disableFallback != undefined) {
                    this.disableFallback = data.disableFallback;
                }
                if ("disableFallbackIfMatch" in data && data.disableFallbackIfMatch != undefined) {
                    this.disableFallbackIfMatch = data.disableFallbackIfMatch;
                }
            }
        }
        get name_server() {
            return pb_1.Message.getRepeatedWrapperField(this, NameServer, 5) as NameServer[];
        }
        set name_server(value: NameServer[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get client_ip() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set client_ip(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get static_hosts() {
            return pb_1.Message.getRepeatedWrapperField(this, Config.HostMapping, 4) as Config.HostMapping[];
        }
        set static_hosts(value: Config.HostMapping[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get tag() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set tag(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get disableCache() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set disableCache(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get query_strategy() {
            return pb_1.Message.getFieldWithDefault(this, 9, QueryStrategy.USE_IP) as QueryStrategy;
        }
        set query_strategy(value: QueryStrategy) {
            pb_1.Message.setField(this, 9, value);
        }
        get disableFallback() {
            return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
        }
        set disableFallback(value: boolean) {
            pb_1.Message.setField(this, 10, value);
        }
        get disableFallbackIfMatch() {
            return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
        }
        set disableFallbackIfMatch(value: boolean) {
            pb_1.Message.setField(this, 11, value);
        }
        static fromObject(data: {
            name_server?: ReturnType<typeof NameServer.prototype.toObject>[];
            client_ip?: Uint8Array;
            static_hosts?: ReturnType<typeof Config.HostMapping.prototype.toObject>[];
            tag?: string;
            disableCache?: boolean;
            query_strategy?: QueryStrategy;
            disableFallback?: boolean;
            disableFallbackIfMatch?: boolean;
        }): Config {
            const message = new Config({});
            if (data.name_server != null) {
                message.name_server = data.name_server.map(item => NameServer.fromObject(item));
            }
            if (data.client_ip != null) {
                message.client_ip = data.client_ip;
            }
            if (data.static_hosts != null) {
                message.static_hosts = data.static_hosts.map(item => Config.HostMapping.fromObject(item));
            }
            if (data.tag != null) {
                message.tag = data.tag;
            }
            if (data.disableCache != null) {
                message.disableCache = data.disableCache;
            }
            if (data.query_strategy != null) {
                message.query_strategy = data.query_strategy;
            }
            if (data.disableFallback != null) {
                message.disableFallback = data.disableFallback;
            }
            if (data.disableFallbackIfMatch != null) {
                message.disableFallbackIfMatch = data.disableFallbackIfMatch;
            }
            return message;
        }
        toObject() {
            const data: {
                name_server?: ReturnType<typeof NameServer.prototype.toObject>[];
                client_ip?: Uint8Array;
                static_hosts?: ReturnType<typeof Config.HostMapping.prototype.toObject>[];
                tag?: string;
                disableCache?: boolean;
                query_strategy?: QueryStrategy;
                disableFallback?: boolean;
                disableFallbackIfMatch?: boolean;
            } = {};
            if (this.name_server != null) {
                data.name_server = this.name_server.map((item: NameServer) => item.toObject());
            }
            if (this.client_ip != null) {
                data.client_ip = this.client_ip;
            }
            if (this.static_hosts != null) {
                data.static_hosts = this.static_hosts.map((item: Config.HostMapping) => item.toObject());
            }
            if (this.tag != null) {
                data.tag = this.tag;
            }
            if (this.disableCache != null) {
                data.disableCache = this.disableCache;
            }
            if (this.query_strategy != null) {
                data.query_strategy = this.query_strategy;
            }
            if (this.disableFallback != null) {
                data.disableFallback = this.disableFallback;
            }
            if (this.disableFallbackIfMatch != null) {
                data.disableFallbackIfMatch = this.disableFallbackIfMatch;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name_server.length)
                writer.writeRepeatedMessage(5, this.name_server, (item: NameServer) => item.serialize(writer));
            if (this.client_ip.length)
                writer.writeBytes(3, this.client_ip);
            if (this.static_hosts.length)
                writer.writeRepeatedMessage(4, this.static_hosts, (item: Config.HostMapping) => item.serialize(writer));
            if (this.tag.length)
                writer.writeString(6, this.tag);
            if (this.disableCache != false)
                writer.writeBool(8, this.disableCache);
            if (this.query_strategy != QueryStrategy.USE_IP)
                writer.writeEnum(9, this.query_strategy);
            if (this.disableFallback != false)
                writer.writeBool(10, this.disableFallback);
            if (this.disableFallbackIfMatch != false)
                writer.writeBool(11, this.disableFallbackIfMatch);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Config {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Config();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 5:
                        reader.readMessage(message.name_server, () => pb_1.Message.addToRepeatedWrapperField(message, 5, NameServer.deserialize(reader), NameServer));
                        break;
                    case 3:
                        message.client_ip = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.static_hosts, () => pb_1.Message.addToRepeatedWrapperField(message, 4, Config.HostMapping.deserialize(reader), Config.HostMapping));
                        break;
                    case 6:
                        message.tag = reader.readString();
                        break;
                    case 8:
                        message.disableCache = reader.readBool();
                        break;
                    case 9:
                        message.query_strategy = reader.readEnum();
                        break;
                    case 10:
                        message.disableFallback = reader.readBool();
                        break;
                    case 11:
                        message.disableFallbackIfMatch = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Config {
            return Config.deserialize(bytes);
        }
    }
    export namespace Config {
        export class HostMapping extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                type?: DomainMatchingType;
                domain?: string;
                ip?: Uint8Array[];
                proxied_domain?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("domain" in data && data.domain != undefined) {
                        this.domain = data.domain;
                    }
                    if ("ip" in data && data.ip != undefined) {
                        this.ip = data.ip;
                    }
                    if ("proxied_domain" in data && data.proxied_domain != undefined) {
                        this.proxied_domain = data.proxied_domain;
                    }
                }
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 1, DomainMatchingType.Full) as DomainMatchingType;
            }
            set type(value: DomainMatchingType) {
                pb_1.Message.setField(this, 1, value);
            }
            get domain() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set domain(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get ip() {
                return pb_1.Message.getFieldWithDefault(this, 3, []) as Uint8Array[];
            }
            set ip(value: Uint8Array[]) {
                pb_1.Message.setField(this, 3, value);
            }
            get proxied_domain() {
                return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
            }
            set proxied_domain(value: string) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                type?: DomainMatchingType;
                domain?: string;
                ip?: Uint8Array[];
                proxied_domain?: string;
            }): HostMapping {
                const message = new HostMapping({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.domain != null) {
                    message.domain = data.domain;
                }
                if (data.ip != null) {
                    message.ip = data.ip;
                }
                if (data.proxied_domain != null) {
                    message.proxied_domain = data.proxied_domain;
                }
                return message;
            }
            toObject() {
                const data: {
                    type?: DomainMatchingType;
                    domain?: string;
                    ip?: Uint8Array[];
                    proxied_domain?: string;
                } = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.domain != null) {
                    data.domain = this.domain;
                }
                if (this.ip != null) {
                    data.ip = this.ip;
                }
                if (this.proxied_domain != null) {
                    data.proxied_domain = this.proxied_domain;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.type != DomainMatchingType.Full)
                    writer.writeEnum(1, this.type);
                if (this.domain.length)
                    writer.writeString(2, this.domain);
                if (this.ip.length)
                    writer.writeRepeatedBytes(3, this.ip);
                if (this.proxied_domain.length)
                    writer.writeString(4, this.proxied_domain);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HostMapping {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HostMapping();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readEnum();
                            break;
                        case 2:
                            message.domain = reader.readString();
                            break;
                        case 3:
                            pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                            break;
                        case 4:
                            message.proxied_domain = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): HostMapping {
                return HostMapping.deserialize(bytes);
            }
        }
    }
}
